diff -pudN e:\wine\dlls\comctl32/comctl32.h e:\reactos\dll\win32\comctl32/comctl32.h
--- e:\wine\dlls\comctl32/comctl32.h	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/comctl32.h	2017-06-15 11:36:56 +0100
@@ -45,83 +45,15 @@
 #include <uxtheme.h>
 #include <vssym32.h>
 
-#include <wine/unicode.h>
 #include <wine/debug.h>
+#include <wine/list.h>
+#include <wine/unicode.h>
 
 #include "resource.h"
 
 extern HMODULE COMCTL32_hModule DECLSPEC_HIDDEN;
 extern HBRUSH  COMCTL32_hPattern55AABrush DECLSPEC_HIDDEN;
 
-/* Property sheet / Wizard */
-#define IDD_PROPSHEET 1006
-#define IDD_WIZARD    1020
-
-#define IDC_TABCONTROL   12320
-#define IDC_APPLY_BUTTON 12321
-#define IDC_BACK_BUTTON  12323
-#define IDC_NEXT_BUTTON  12324
-#define IDC_FINISH_BUTTON 12325
-#define IDC_SUNKEN_LINE   12326
-#define IDC_SUNKEN_LINEHEADER 12327
-
-#define IDS_CLOSE	  4160
-
-/* Toolbar customization dialog */
-#define IDD_TBCUSTOMIZE     200
-
-#define IDC_AVAILBTN_LBOX   201
-#define IDC_RESET_BTN       202
-#define IDC_TOOLBARBTN_LBOX 203
-#define IDC_REMOVE_BTN      204
-#define IDC_HELP_BTN        205
-#define IDC_MOVEUP_BTN      206
-#define IDC_MOVEDN_BTN      207
-
-#define IDS_SEPARATOR      1024
-
-/* Toolbar imagelist bitmaps */
-#define IDB_STD_SMALL       120
-#define IDB_STD_LARGE       121
-#define IDB_VIEW_SMALL      124
-#define IDB_VIEW_LARGE      125
-#define IDB_HIST_SMALL      130
-#define IDB_HIST_LARGE      131
-
-#define IDM_TODAY                      4163
-#define IDM_GOTODAY                    4164
-
-/* Treeview Checkboxes */
-
-#define IDT_CHECK        401
-
-
-/* Cursors */
-#define IDC_MOVEBUTTON                  102
-#define IDC_COPY                        104
-#define IDC_DIVIDER                     106
-#define IDC_DIVIDEROPEN                 107
-
-
-/* DragList resources */
-#define IDI_DRAGARROW                   501
-
-/* HOTKEY internal strings */
-#define HKY_NONE                        2048
-
-/* Tooltip icons */
-#define IDI_TT_INFO_SM                   22
-#define IDI_TT_WARN_SM                   25
-#define IDI_TT_ERROR_SM                  28
-
-/* Taskdialog strings */
-#define IDS_BUTTON_YES    3000
-#define IDS_BUTTON_NO     3001
-#define IDS_BUTTON_RETRY  3002
-#define IDS_BUTTON_OK     3003
-#define IDS_BUTTON_CANCEL 3004
-#define IDS_BUTTON_CLOSE  3005
-
 typedef struct
 {
     COLORREF clrBtnHighlight;       /* COLOR_BTNHIGHLIGHT                  */
@@ -145,6 +77,21 @@ typedef struct
 
 extern COMCTL32_SysColor  comctl32_color DECLSPEC_HIDDEN;
 
+typedef struct _BUTTON_DATA {
+    LONG state;
+    HFONT font;
+    LONG_PTR image;
+    DWORD ui_state;
+
+    RECT rcTextMargin;
+    BUTTON_IMAGELIST imlData;
+} BUTTON_DATA, *PBUTTON_DATA;
+
+static inline PBUTTON_DATA _GetButtonData(HWND hwnd)
+{
+    return (PBUTTON_DATA)GetWindowLongPtrW( hwnd, 0 );
+}
+
 /* Internal function */
 HWND COMCTL32_CreateToolTip (HWND) DECLSPEC_HIDDEN;
 VOID COMCTL32_RefreshSysColors(void) DECLSPEC_HIDDEN;
@@ -157,8 +104,6 @@ INT  Str_GetPtrAtoW (LPCSTR lpSrc, LPWST
 BOOL Str_SetPtrAtoW (LPWSTR *lppDest, LPCSTR lpSrc) DECLSPEC_HIDDEN;
 BOOL Str_SetPtrWtoA (LPSTR *lppDest, LPCWSTR lpSrc) DECLSPEC_HIDDEN;
 
-#define COMCTL32_VERSION_MINOR 81
-
 /* Our internal stack structure of the window procedures to subclass */
 typedef struct _SUBCLASSPROCS {
     SUBCLASSPROC subproc;
@@ -230,13 +175,18 @@ extern void TREEVIEW_Register(void) DECL
 extern void TREEVIEW_Unregister(void) DECLSPEC_HIDDEN;
 extern void UPDOWN_Register(void) DECLSPEC_HIDDEN;
 extern void UPDOWN_Unregister(void) DECLSPEC_HIDDEN;
-
+extern void BUTTON_Register();
+extern void BUTTON_Unregister();
+#ifdef __REACTOS__
+extern void TOOLBARv6_Register(void) DECLSPEC_HIDDEN;
+extern void TOOLBARv6_Unregister(void) DECLSPEC_HIDDEN;
+#endif
 
 int MONTHCAL_MonthLength(int month, int year) DECLSPEC_HIDDEN;
 int MONTHCAL_CalculateDayOfWeek(SYSTEMTIME *date, BOOL inplace) DECLSPEC_HIDDEN;
 LONG MONTHCAL_CompareSystemTime(const SYSTEMTIME *first, const SYSTEMTIME *second) DECLSPEC_HIDDEN;
 
-extern void THEMING_Initialize(void) DECLSPEC_HIDDEN;
+extern void THEMING_Initialize(HANDLE hActCtx5, HANDLE hActCtx6) DECLSPEC_HIDDEN;
 extern void THEMING_Uninitialize(void) DECLSPEC_HIDDEN;
 extern LRESULT THEMING_CallOriginalClass(HWND, UINT, WPARAM, LPARAM) DECLSPEC_HIDDEN;
 extern void THEMING_SetSubclassData(HWND, ULONG_PTR) DECLSPEC_HIDDEN;
diff -pudN e:\wine\dlls\comctl32/commctrl.c e:\reactos\dll\win32\comctl32/commctrl.c
--- e:\wine\dlls\comctl32/commctrl.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/commctrl.c	2017-08-17 11:24:56 +0100
@@ -3,7 +3,7 @@
  *
  * Copyright 1997 Dimitrie O. Paun
  * Copyright 1998,2000 Eric Kohl
- * Copyright 2014-2015 Michael MÃ¼ller
+ * Copyright 2014-2015 Michael Müller
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -81,6 +81,259 @@ static const WCHAR strCC32SubclassInfo[]
     'C','C','3','2','S','u','b','c','l','a','s','s','I','n','f','o',0
 };
 
+#ifdef __REACTOS__
+
+#include <strsafe.h>
+
+#define NAME       L"microsoft.windows.common-controls"
+#define VERSION_V5 L"5.82.2600.2982"
+#define VERSION    L"6.0.2600.2982"
+#define PUBLIC_KEY L"6595b64144ccf1df"
+
+#ifdef __i386__
+#define ARCH L"x86"
+#elif defined __x86_64__
+#define ARCH L"amd64"
+#else
+#define ARCH L"none"
+#endif
+
+static const WCHAR manifest_filename[] = ARCH L"_" NAME L"_" PUBLIC_KEY L"_" VERSION L"_none_deadbeef.manifest";
+static const WCHAR manifest_filename_v5[] = ARCH L"_" NAME L"_" PUBLIC_KEY L"_" VERSION_V5 L"_none_deadbeef.manifest";
+
+static WCHAR* GetManifestPath(BOOL create, BOOL bV6)
+{
+    WCHAR *pwszBuf;
+    HRESULT hres;
+
+    pwszBuf = HeapAlloc(GetProcessHeap(), 0, MAX_PATH * sizeof(WCHAR));
+    if (!pwszBuf)
+        return NULL;
+
+    GetWindowsDirectoryW(pwszBuf, MAX_PATH);
+    hres = StringCchCatW(pwszBuf, MAX_PATH, L"\\winsxs");
+    if (FAILED(hres))
+        return NULL;
+    if (create)
+        CreateDirectoryW(pwszBuf, NULL);
+    hres = StringCchCatW(pwszBuf, MAX_PATH, L"\\manifests\\");
+    if (FAILED(hres))
+        return NULL;
+    if (create)
+        CreateDirectoryW(pwszBuf, NULL);
+
+    hres = StringCchCatW(pwszBuf, MAX_PATH, bV6 ? manifest_filename : manifest_filename_v5);
+    if (FAILED(hres))
+        return NULL;
+
+    return pwszBuf;
+}
+
+static BOOL create_manifest(BOOL install, BOOL bV6)
+{
+    WCHAR *pwszBuf;
+    HRSRC hResInfo;
+    HGLOBAL hResData;
+    PVOID pManifest;
+    DWORD cbManifest, cbWritten;
+    HANDLE hFile;
+    BOOL bRet = FALSE;
+
+    if (bV6)
+        hResInfo = FindResourceW(COMCTL32_hModule, L"WINE_MANIFEST", (LPWSTR)RT_MANIFEST);
+    else
+        hResInfo = FindResourceW(COMCTL32_hModule, L"WINE_MANIFESTV5", (LPWSTR)RT_MANIFEST);
+
+    if (!hResInfo)
+        return FALSE;
+
+    cbManifest = SizeofResource(COMCTL32_hModule, hResInfo);
+    if (!cbManifest)
+        return FALSE;
+
+    hResData = LoadResource(COMCTL32_hModule, hResInfo);
+    if (!hResData)
+        return FALSE;
+
+    pManifest = LockResource(hResData);
+    if (!pManifest)
+        return FALSE;
+
+    pwszBuf = GetManifestPath(TRUE, bV6);
+    if (!pwszBuf)
+        return FALSE;
+
+    if (install)
+    {
+        hFile = CreateFileW(pwszBuf, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
+        if (hFile != INVALID_HANDLE_VALUE)
+        {
+            if (WriteFile(hFile, pManifest, cbManifest, &cbWritten, NULL) && cbWritten == cbManifest)
+                bRet = TRUE;
+
+            CloseHandle(hFile);
+
+            if (!bRet)
+                DeleteFileW(pwszBuf);
+            else
+                TRACE("created %s\n", debugstr_w(pwszBuf));
+        }
+    }
+    else
+        bRet = DeleteFileW(pwszBuf);
+
+    HeapFree(GetProcessHeap(), 0, pwszBuf);
+
+    return bRet;
+}
+
+static HANDLE CreateComctl32ActCtx(BOOL bV6)
+{
+    HANDLE ret;
+    WCHAR* pwstrSource;
+    ACTCTXW ActCtx = {sizeof(ACTCTX)};
+
+    pwstrSource = GetManifestPath(FALSE, bV6);
+    if (!pwstrSource)
+    {
+        ERR("GetManifestPath failed! bV6=%d\n", bV6);
+        return INVALID_HANDLE_VALUE;
+    }
+    ActCtx.lpSource = pwstrSource;
+    ret = CreateActCtxW(&ActCtx);
+    HeapFree(GetProcessHeap(), 0, pwstrSource);
+    if (ret == INVALID_HANDLE_VALUE)
+        ERR("CreateActCtxW failed! bV6=%d\n", bV6);
+    return ret;
+}
+
+static void RegisterControls(BOOL bV6)
+{
+    ANIMATE_Register ();
+    COMBOEX_Register ();
+    DATETIME_Register ();
+    FLATSB_Register ();
+    HEADER_Register ();
+    HOTKEY_Register ();
+    IPADDRESS_Register ();
+    LISTVIEW_Register ();
+    MONTHCAL_Register ();
+    NATIVEFONT_Register ();
+    PAGER_Register ();
+    PROGRESS_Register ();
+    REBAR_Register ();
+    STATUS_Register ();
+    SYSLINK_Register ();
+    TAB_Register ();
+    TOOLTIPS_Register ();
+    TRACKBAR_Register ();
+    TREEVIEW_Register ();
+    UPDOWN_Register ();
+
+    if (!bV6)
+    {
+        TOOLBAR_Register ();
+    }
+    else
+    {
+        BUTTON_Register();
+        TOOLBARv6_Register();
+    }
+}
+
+static void UnregisterControls(BOOL bV6)
+{
+    ANIMATE_Unregister ();
+    COMBOEX_Unregister ();
+    DATETIME_Unregister ();
+    FLATSB_Unregister ();
+    HEADER_Unregister ();
+    HOTKEY_Unregister ();
+    IPADDRESS_Unregister ();
+    LISTVIEW_Unregister ();
+    MONTHCAL_Unregister ();
+    NATIVEFONT_Unregister ();
+    PAGER_Unregister ();
+    PROGRESS_Unregister ();
+    REBAR_Unregister ();
+    STATUS_Unregister ();
+    SYSLINK_Unregister ();
+    TAB_Unregister ();
+    TOOLTIPS_Unregister ();
+    TRACKBAR_Unregister ();
+    TREEVIEW_Unregister ();
+    UPDOWN_Unregister ();
+
+    if (!bV6)
+    {
+        TOOLBAR_Unregister ();
+    }
+    else
+    {
+        BUTTON_Unregister();
+        TOOLBARv6_Unregister ();
+    }
+
+}
+
+static void InitializeClasses()
+{
+    HANDLE hActCtx5, hActCtx6;
+    BOOL activated;
+    ULONG_PTR ulCookie;
+
+    /* like comctl32 5.82+ register all the common control classes */
+    /* Register the classes once no matter what */
+    hActCtx5 = CreateComctl32ActCtx(FALSE);
+    activated = (hActCtx5 != INVALID_HANDLE_VALUE ? ActivateActCtx(hActCtx5, &ulCookie) : FALSE);
+    RegisterControls(FALSE);      /* Register the classes pretending to be v5 */
+    if (activated) DeactivateActCtx(0, ulCookie);
+
+    hActCtx6 = CreateComctl32ActCtx(TRUE);
+    if (hActCtx6 != INVALID_HANDLE_VALUE)
+    {
+        activated = ActivateActCtx(hActCtx6, &ulCookie);
+        RegisterControls(TRUE);      /* Register the classes pretending to be v6 */
+        if (activated) DeactivateActCtx(0, ulCookie);
+
+        /* Initialize the themed controls only when the v6 manifest is present */
+        THEMING_Initialize (hActCtx5, hActCtx6);
+    }
+}
+
+static void UninitializeClasses()
+{
+    HANDLE hActCtx5, hActCtx6;
+    BOOL activated;
+    ULONG_PTR ulCookie;
+
+    hActCtx5 = CreateComctl32ActCtx(FALSE);
+    activated = (hActCtx5 != INVALID_HANDLE_VALUE ? ActivateActCtx(hActCtx5, &ulCookie) : FALSE);
+    UnregisterControls(FALSE);
+    if (activated) DeactivateActCtx(0, ulCookie);
+
+    hActCtx6 = CreateComctl32ActCtx(TRUE);
+    if (hActCtx6 != INVALID_HANDLE_VALUE)
+    {
+        activated = ActivateActCtx(hActCtx6, &ulCookie);
+        THEMING_Uninitialize();
+        UnregisterControls(TRUE);
+        if (activated) DeactivateActCtx(0, ulCookie);
+    }
+}
+
+/***********************************************************************
+ * RegisterClassNameW [COMCTL32.@]
+ *
+ * Register window class again while using as SxS module.
+ */
+BOOLEAN WINAPI RegisterClassNameW(LPCWSTR className)
+{
+    InitializeClasses();
+    return TRUE;
+}
+
+#endif
 
 /***********************************************************************
  * DllMain [Internal]
@@ -118,6 +371,7 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
 	    /* Get all the colors at DLL load */
 	    COMCTL32_RefreshSysColors();
 
+#ifndef __REACTOS__
             /* like comctl32 5.82+ register all the common control classes */
             ANIMATE_Register ();
             COMBOEX_Register ();
@@ -143,10 +397,15 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
 
             /* subclass user32 controls */
             THEMING_Initialize ();
+#else
+            InitializeClasses();
+#endif
+
             break;
 
 	case DLL_PROCESS_DETACH:
             if (lpvReserved) break;
+#ifndef __REACTOS__
             /* clean up subclassing */
             THEMING_Uninitialize();
 
@@ -172,7 +431,9 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
             TRACKBAR_Unregister ();
             TREEVIEW_Unregister ();
             UPDOWN_Unregister ();
-
+#else
+            UninitializeClasses();
+#endif
             /* delete local pattern brush */
             DeleteObject (COMCTL32_hPattern55AABrush);
             DeleteObject (COMCTL32_hPattern55AABitmap);
@@ -917,6 +1178,22 @@ HRESULT WINAPI DllGetVersion (DLLVERSION
 HRESULT WINAPI DllInstall(BOOL bInstall, LPCWSTR cmdline)
 {
     TRACE("(%u, %s): stub\n", bInstall, debugstr_w(cmdline));
+
+#ifdef __REACTOS__
+
+    if (!create_manifest(bInstall, TRUE))
+    {
+        ERR("Failed to install comctl32 v6 manifest!\n");
+        return HRESULT_FROM_WIN32(GetLastError());
+    }
+
+    if (!create_manifest(bInstall, FALSE))
+    {
+        ERR("Failed to install comctl32 v5 manifest!\n");
+        return HRESULT_FROM_WIN32(GetLastError());
+    }
+#endif
+
     return S_OK;
 }
 
@@ -1580,33 +1857,113 @@ LRESULT WINAPI SetPathWordBreakProc(HWND
  *
  * Draw text with shadow.
  */
-int WINAPI DrawShadowText(HDC hdc, LPCWSTR text, UINT length, RECT *rect, DWORD flags,
-                          COLORREF crText, COLORREF crShadow, int offset_x, int offset_y)
+int WINAPI DrawShadowText(HDC hdc, LPCWSTR pszText, UINT cch, RECT *prc, DWORD dwFlags,
+                          COLORREF crText, COLORREF crShadow, int ixOffset, int iyOffset)
 {
-    int bkmode, ret;
-    COLORREF clr;
-    RECT r;
+    COLORREF crOldText;
+    RECT rcText;
+    INT iRet, x, y, x2, y2;
+    BYTE *pBits;
+    HBITMAP hbm, hbmOld;
+    BITMAPINFO bi;
+    HDC hdcMem;
+    HFONT hOldFont;
+    BLENDFUNCTION bf;
 
-    FIXME("(%p, %s, %d, %p, 0x%08x, 0x%08x, 0x%08x, %d, %d): semi-stub\n", hdc, debugstr_w(text),
-        length, rect, flags, crText, crShadow, offset_x, offset_y);
+    /* Create 32 bit DIB section for the shadow */
+    ZeroMemory(&bi, sizeof(bi));
+    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
+    bi.bmiHeader.biWidth = prc->right - prc->left + 4;
+    bi.bmiHeader.biHeight = prc->bottom - prc->top + 5; // bottom-up DIB
+    bi.bmiHeader.biPlanes = 1;
+    bi.bmiHeader.biBitCount = 32;
+    bi.bmiHeader.biCompression = BI_RGB;
+    hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, (PVOID*)&pBits, NULL, 0);
+    if(!hbm)
+    {
+        ERR("CreateDIBSection failed\n");
+        return 0;
+    }
 
-    bkmode = SetBkMode(hdc, TRANSPARENT);
-    clr = SetTextColor(hdc, crShadow);
+    /* Create memory device context for new DIB section and select it */
+    hdcMem = CreateCompatibleDC(hdc);
+    if(!hdcMem)
+    {
+        ERR("CreateCompatibleDC failed\n");
+        DeleteObject(hbm);

+        return 0;
+    }
 
-    /* FIXME: for shadow we need to render normally, blur it, and blend with current background. */
-    r = *rect;
-    OffsetRect(&r, 1, 1);
-    DrawTextW(hdc, text, length, &r, flags);
+    hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);
 
-    SetTextColor(hdc, crText);
+    /* Draw text on our helper bitmap */
+    hOldFont = (HFONT)SelectObject(hdcMem, GetCurrentObject(hdc, OBJ_FONT));
+    SetTextColor(hdcMem, RGB(16, 16, 16));
+    SetBkColor(hdcMem, RGB(0, 0, 0));
+    SetBkMode(hdcMem, TRANSPARENT);
+    SetRect(&rcText, 0, 0, prc->right - prc->left, prc->bottom - prc->top);
+    DrawTextW(hdcMem, pszText, cch, &rcText, dwFlags);
+    SelectObject(hdcMem, hOldFont);
 
-    /* with text color on top of a shadow */
-    ret = DrawTextW(hdc, text, length, rect, flags);
+    /* Flush GDI so data pointed by pBits is valid */
+    GdiFlush();
 
-    SetTextColor(hdc, clr);
-    SetBkMode(hdc, bkmode);
+    /* Set alpha of pixels (forget about colors for now. They will be changed in next loop).
+       We copy text image 4*5 times and each time alpha is added */
+    for (x = 0; x < bi.bmiHeader.biWidth; ++x)
+        for (y = 0; y < bi.bmiHeader.biHeight; ++y)
+        {
+            BYTE *pDest = &pBits[(y * bi.bmiHeader.biWidth + x) * 4];
+            UINT Alpha = 0;
 
-    return ret;
+            for (x2 = x - 4 + 1; x2 <= x; ++x2)
+                for (y2 = y; y2 < y + 5; ++y2)
+                {
+                    if (x2 >= 0 && x2 < bi.bmiHeader.biWidth && y2 >= 0 && y2 < bi.bmiHeader.biHeight)
+                    {
+                        BYTE *pSrc = &pBits[(y2 * bi.bmiHeader.biWidth + x2) * 4];
+                        Alpha += pSrc[0];
+                    }
+                }
+
+            if (Alpha > 255)
+                Alpha = 255;
+            pDest[3] = Alpha;
+        }
+
+    /* Now set the color of each pixel to shadow color * alpha (see GdiAlphaBlend) */
+    for (x = 0; x < bi.bmiHeader.biWidth; ++x)
+        for (y = 0; y < bi.bmiHeader.biHeight; ++y)
+        {
+            BYTE *pDest = &pBits[(y * bi.bmiHeader.biWidth + x) * 4];
+            pDest[0] = GetBValue(crShadow) * pDest[3] / 255;
+            pDest[1] = GetGValue(crShadow) * pDest[3] / 255;
+            pDest[2] = GetRValue(crShadow) * pDest[3] / 255;
+        }
+
+    /* Fix ixOffset of the shadow (tested on Win) */
+    ixOffset -= 3;
+    iyOffset -= 3;
+
+    /* Alpha blend helper image to destination DC */
+    bf.BlendOp = AC_SRC_OVER;
+    bf.BlendFlags = 0;
+    bf.SourceConstantAlpha = 255;
+    bf.AlphaFormat = AC_SRC_ALPHA;
+    GdiAlphaBlend(hdc, prc->left + ixOffset, prc->top + iyOffset, bi.bmiHeader.biWidth, bi.bmiHeader.biHeight, hdcMem, 0, 0, bi.bmiHeader.biWidth, bi.bmiHeader.biHeight, bf);
+
+    /* Delete the helper bitmap */
+    SelectObject(hdcMem, hbmOld);
+    DeleteObject(hbm);
+    DeleteDC(hdcMem);
+
+    /* Finally draw the text over shadow */
+    crOldText = SetTextColor(hdc, crText);
+    SetBkMode(hdc, TRANSPARENT);
+    iRet = DrawTextW(hdc, pszText, cch, prc, dwFlags);
+    SetTextColor(hdc, crOldText);
+
+    return iRet;
 }
 
 /***********************************************************************
diff -pudN e:\wine\dlls\comctl32/imagelist.c e:\reactos\dll\win32\comctl32/imagelist.c
--- e:\wine\dlls\comctl32/imagelist.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/imagelist.c	2017-05-07 14:47:57 +0100
@@ -33,7 +33,7 @@
  *
  *  TODO:
  *    - Add support for ILD_PRESERVEALPHA, ILD_SCALE, ILD_DPISCALE
- *    - Add support for ILS_GLOW, ILS_SHADOW, ILS_SATURATE
+ *    - Add support for ILS_GLOW, ILS_SHADOW
  *    - Thread-safe locking
  */
 
@@ -1243,8 +1243,11 @@ ImageList_DrawEx (HIMAGELIST himl, INT i
     return ImageList_DrawIndirect (&imldp);
 }
 
-
+#ifdef __REACTOS__
+static BOOL alpha_blend_image( HIMAGELIST himl, HDC srce_dc, HDC dest_dc, int dest_x, int dest_y,
+#else
 static BOOL alpha_blend_image( HIMAGELIST himl, HDC dest_dc, int dest_x, int dest_y,
+#endif
                                int src_x, int src_y, int cx, int cy, BLENDFUNCTION func,
                                UINT style, COLORREF blend_col )
 {
@@ -1269,9 +1272,17 @@ static BOOL alpha_blend_image( HIMAGELIS
     info->bmiHeader.biYPelsPerMeter = 0;
     info->bmiHeader.biClrUsed = 0;
     info->bmiHeader.biClrImportant = 0;
+#ifdef __REACTOS__
+    if (!(bmp = CreateDIBSection( srce_dc, info, DIB_RGB_COLORS, &bits, 0, 0 ))) goto done;
+#else
     if (!(bmp = CreateDIBSection( himl->hdcImage, info, DIB_RGB_COLORS, &bits, 0, 0 ))) goto done;
+#endif
     SelectObject( hdc, bmp );
+#ifdef __REACTOS__
+    BitBlt( hdc, 0, 0, cx, cy, srce_dc, src_x, src_y, SRCCOPY );
+#else
     BitBlt( hdc, 0, 0, cx, cy, himl->hdcImage, src_x, src_y, SRCCOPY );
+#endif
 
     if (blend_col != CLR_NONE)
     {
@@ -1344,6 +1355,68 @@ done:
     return ret;
 }
 
+#ifdef __REACTOS__
+HDC saturate_image( HIMAGELIST himl, HDC dest_dc, int dest_x, int dest_y,
+                    int src_x, int src_y, int cx, int cy, COLORREF rgbFg)
+{
+    HDC hdc = NULL;
+    HBITMAP bmp = 0;
+    BITMAPINFO *info;
+
+    unsigned int *ptr;
+    void *bits;
+    int i;
+
+    /* create a dc and its device independent bitmap for doing the work,
+       shamelessly copied from the alpha-blending function above */
+    if (!(hdc = CreateCompatibleDC( 0 ))) return FALSE;
+    if (!(info = HeapAlloc( GetProcessHeap(), 0, FIELD_OFFSET( BITMAPINFO, bmiColors[256] )))) goto done;
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = cx;
+    info->bmiHeader.biHeight = cy;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = cx * cy * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+    if (!(bmp = CreateDIBSection(himl->hdcImage, info, DIB_RGB_COLORS, &bits, 0, 0 ))) goto done;
+
+    /* bind both surfaces */
+    SelectObject(hdc, bmp);
+
+    /* copy into our dc the section that covers just the icon we we're asked for */
+    BitBlt(hdc, 0, 0, cx, cy, himl->hdcImage, src_x, src_y, SRCCOPY);
+
+    /* loop every pixel of the bitmap */
+    for (i = 0, ptr = bits; i < cx * cy; i++, ptr++)
+    {
+        COLORREF orig_color = *ptr;
+
+        /* calculate the effective luminance using the constants from here, adapted to the human eye:
+           <http://bobpowell.net/grayscale.aspx> */
+        float mixed_color = (GetRValue(orig_color) * .30 +
+                             GetGValue(orig_color) * .59 +
+                             GetBValue(orig_color) * .11);
+
+        *ptr = RGBA(mixed_color, mixed_color, mixed_color, GetAValue(orig_color));
+    }
+
+done:
+
+    if (bmp)
+        DeleteObject(bmp);
+
+    if (info)
+        HeapFree(GetProcessHeap(), 0, info);
+
+    /* return the handle to our desaturated dc, that will substitute its original counterpart in the next calls */
+    return hdc;
+}
+#endif /* __REACTOS__ */
+
 /*************************************************************************
  * ImageList_DrawIndirect [COMCTL32.@]
  *
@@ -1371,6 +1444,9 @@ ImageList_DrawIndirect (IMAGELISTDRAWPAR
     HBRUSH hOldBrush;
     POINT pt;
     BOOL has_alpha;
+#ifdef __REACTOS__
+    HDC hdcSaturated = NULL;
+#endif
 
     if (!pimldp || !(himl = pimldp->himl)) return FALSE;
     if (!is_valid(himl)) return FALSE;
@@ -1420,6 +1496,24 @@ ImageList_DrawIndirect (IMAGELISTDRAWPAR
     oldImageFg = SetTextColor( hImageDC, RGB( 0, 0, 0 ) );
     oldImageBk = SetBkColor( hImageDC, RGB( 0xff, 0xff, 0xff ) );
 
+#ifdef __REACTOS__
+    /*
+     * If the ILS_SATURATE bit is enabled we should multiply the
+     * RGB colors of the original image by the contents of rgbFg.
+     */
+    if (fState & ILS_SATURATE)
+    {
+        hdcSaturated = saturate_image(himl, pimldp->hdcDst, pimldp->x, pimldp->y,
+                                      pt.x, pt.y, cx, cy, pimldp->rgbFg);
+
+        hImageListDC = hdcSaturated;
+        /* shitty way of getting subroutines to blit at the right place (top left corner),
+           as our modified imagelist only contains a single image for performance reasons */
+        pt.x = 0;
+        pt.y = 0;
+    }
+#endif
+
     has_alpha = (himl->has_alpha && himl->has_alpha[pimldp->i]);
     if (!bMask && (has_alpha || (fState & ILS_ALPHA)))
     {
@@ -1440,7 +1534,11 @@ ImageList_DrawIndirect (IMAGELISTDRAWPAR
 
         if (bIsTransparent)
         {
+#ifdef __REACTOS__
+            bResult = alpha_blend_image( himl, hImageListDC, pimldp->hdcDst, pimldp->x, pimldp->y,
+#else
             bResult = alpha_blend_image( himl, pimldp->hdcDst, pimldp->x, pimldp->y,
+#endif
                                          pt.x, pt.y, cx, cy, func, fStyle, blend_col );
             goto end;
         }
@@ -1450,7 +1548,11 @@ ImageList_DrawIndirect (IMAGELISTDRAWPAR
 
         hOldBrush = SelectObject (hImageDC, CreateSolidBrush (colour));
         PatBlt( hImageDC, 0, 0, cx, cy, PATCOPY );
+#ifdef __REACTOS__
+        alpha_blend_image( himl, hImageListDC, hImageDC, 0, 0, pt.x, pt.y, cx, cy, func, fStyle, blend_col );
+#else
         alpha_blend_image( himl, hImageDC, 0, 0, pt.x, pt.y, cx, cy, func, fStyle, blend_col );
+#endif
         DeleteObject (SelectObject (hImageDC, hOldBrush));
         bResult = BitBlt( pimldp->hdcDst, pimldp->x,  pimldp->y, cx, cy, hImageDC, 0, 0, SRCCOPY );
         goto end;
@@ -1544,7 +1646,9 @@ ImageList_DrawIndirect (IMAGELISTDRAWPAR
 	}
     }
 
+#ifndef __REACTOS__
     if (fState & ILS_SATURATE) FIXME("ILS_SATURATE: unimplemented!\n");
+#endif
     if (fState & ILS_GLOW) FIXME("ILS_GLOW: unimplemented!\n");
     if (fState & ILS_SHADOW) FIXME("ILS_SHADOW: unimplemented!\n");
 
@@ -1572,6 +1676,10 @@ end:
     SetTextColor(hImageDC, oldImageFg);
     SelectObject(hImageDC, hOldImageBmp);
 cleanup:
+#ifdef __REACTOS__
+    if (hdcSaturated)
+        DeleteDC(hdcSaturated);
+#endif
     DeleteObject(hBlendMaskBmp);
     DeleteObject(hImageBmp);
     DeleteDC(hImageDC);
Common subdirectories: e:\wine\dlls\comctl32/lang and e:\reactos\dll\win32\comctl32/lang
diff -pudN e:\wine\dlls\comctl32/listview.c e:\reactos\dll\win32\comctl32/listview.c
--- e:\wine\dlls\comctl32/listview.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/listview.c	2017-08-04 10:38:09 +0100
@@ -286,6 +286,9 @@ typedef struct tagLISTVIEW_INFO
   COLORREF clrBk;
   COLORREF clrText;
   COLORREF clrTextBk;
+#ifdef __REACTOS__
+  BOOL bDefaultBkColor;
+#endif
 
   /* font */
   HFONT hDefaultFont;
@@ -1695,8 +1698,24 @@ static inline BOOL LISTVIEW_GetItemW(con
 /* used to handle collapse main item column case */
 static inline BOOL LISTVIEW_DrawFocusRect(const LISTVIEW_INFO *infoPtr, HDC hdc)
 {
+#ifdef __REACTOS__
+    BOOL Ret = FALSE;
+
+    if (infoPtr->rcFocus.left < infoPtr->rcFocus.right)
+    {
+        DWORD dwOldBkColor, dwOldTextColor;
+
+        dwOldBkColor = SetBkColor(hdc, RGB(255, 255, 255));
+        dwOldTextColor = SetBkColor(hdc, RGB(0, 0, 0));
+        Ret = DrawFocusRect(hdc, &infoPtr->rcFocus);
+        SetBkColor(hdc, dwOldBkColor);
+        SetBkColor(hdc, dwOldTextColor);
+    }
+    return Ret;
+#else
     return (infoPtr->rcFocus.left < infoPtr->rcFocus.right) ?
             DrawFocusRect(hdc, &infoPtr->rcFocus) : FALSE;
+#endif
 }
 
 /* Listview invalidation functions: use _only_ these functions to invalidate */
@@ -2202,8 +2221,9 @@ static void LISTVIEW_ShowFocusRect(const
 	SelectObject(hdc, hOldFont);
     }
     else
-        LISTVIEW_InvalidateItem(infoPtr, infoPtr->nFocusedItem);
-
+    {
+	LISTVIEW_DrawFocusRect(infoPtr, hdc);
+    }
 done:
     ReleaseDC(infoPtr->hwndSelf, hdc);
 }
@@ -4707,7 +4727,12 @@ static void LISTVIEW_DrawItemPart(LISTVI
     if (infoPtr->uView == LV_VIEW_DETAILS && infoPtr->dwLvExStyle & LVS_EX_GRIDLINES)
         rcLabel.bottom--;
 
-    DrawTextW(nmlvcd->nmcd.hdc, item->pszText, -1, &rcLabel, format);
+#ifdef __REACTOS__
+    if ((!(item->state & LVIS_SELECTED) || !infoPtr->bFocus) && (infoPtr->dwLvExStyle & LVS_EX_TRANSPARENTSHADOWTEXT))
+        DrawShadowText(nmlvcd->nmcd.hdc, item->pszText, -1, &rcLabel, format, RGB(255, 255, 255), RGB(0, 0, 0), 2, 2);
+    else
+#endif
+        DrawTextW(nmlvcd->nmcd.hdc, item->pszText, -1, &rcLabel, format);
 }
 
 /***
@@ -5251,7 +5276,11 @@ enddraw:
 
     /* Draw marquee rectangle if appropriate */
     if (infoPtr->bMarqueeSelect)
+    {
+        SetBkColor(hdc, RGB(255, 255, 255));
+        SetTextColor(hdc, RGB(0, 0, 0));
         DrawFocusRect(hdc, &infoPtr->marqueeDrawRect);
+    }
 
     if (cdmode & CDRF_NOTIFYPOSTPAINT)
 	notify_postpaint(infoPtr, &nmlvcd);
@@ -8056,6 +8085,9 @@ static BOOL LISTVIEW_SetBkColor(LISTVIEW
 {
     TRACE("(color=%x)\n", color);
 
+#ifdef __REACTOS__
+    infoPtr->bDefaultBkColor = FALSE;
+#endif
     if(infoPtr->clrBk != color) {
 	if (infoPtr->clrBk != CLR_NONE) DeleteObject(infoPtr->hBkBrush);
 	infoPtr->clrBk = color;
@@ -8731,7 +8763,7 @@ static DWORD LISTVIEW_SetIconSpacing(LIS
     return oldspacing;
 }
 
-static inline void set_icon_size(SIZE *size, HIMAGELIST himl, BOOL small)
+static inline void set_icon_size(SIZE *size, HIMAGELIST himl, BOOL is_small)
 {
     INT cx, cy;
     
@@ -8742,8 +8774,8 @@ static inline void set_icon_size(SIZE *s
     }
     else
     {
-	size->cx = GetSystemMetrics(small ? SM_CXSMICON : SM_CXICON);
-	size->cy = GetSystemMetrics(small ? SM_CYSMICON : SM_CYICON);
+	size->cx = GetSystemMetrics(is_small ? SM_CXSMICON : SM_CXICON);
+	size->cy = GetSystemMetrics(is_small ? SM_CYSMICON : SM_CYICON);
     }
 }
 
@@ -9477,6 +9509,9 @@ static LRESULT LISTVIEW_NCCreate(HWND hw
   infoPtr->clrText = CLR_DEFAULT;
   infoPtr->clrTextBk = CLR_DEFAULT;
   LISTVIEW_SetBkColor(infoPtr, comctl32_color.clrWindow);
+#ifdef __REACTOS__
+  infoPtr->bDefaultBkColor = TRUE;
+#endif
 
   /* set default values */
   infoPtr->nFocusedItem = -1;
@@ -10622,8 +10657,15 @@ static BOOL LISTVIEW_NCPaint(const LISTV
         CombineRgn (cliprgn, cliprgn, region, RGN_AND);
     OffsetRect(&r, -r.left, -r.top);
 
+#ifdef __REACTOS__ /* r73789 */
+    dc = GetWindowDC(infoPtr->hwndSelf);
+    /* Exclude client part */
+    ExcludeClipRect(dc, r.left + cxEdge, r.top + cyEdge,
+        r.right - cxEdge, r.bottom -cyEdge);
+#else
     dc = GetDCEx(infoPtr->hwndSelf, region, DCX_WINDOW|DCX_INTERSECTRGN);
     OffsetRect(&r, -r.left, -r.top);
+#endif
 
     if (IsThemeBackgroundPartiallyTransparent (theme, 0, 0))
         DrawThemeParentBackground(infoPtr->hwndSelf, dc, &r);
@@ -11761,6 +11803,14 @@ LISTVIEW_WindowProc(HWND hwnd, UINT uMsg
 
   case WM_SYSCOLORCHANGE:
     COMCTL32_RefreshSysColors();
+#ifdef __REACTOS__
+    if (infoPtr->bDefaultBkColor)
+    {
+        LISTVIEW_SetBkColor(infoPtr, comctl32_color.clrWindow);
+        infoPtr->bDefaultBkColor = TRUE;
+        LISTVIEW_InvalidateList(infoPtr);
+    }
+#endif
     return 0;
 
 /*	case WM_TIMER: */
diff -pudN e:\wine\dlls\comctl32/monthcal.c e:\reactos\dll\win32\comctl32/monthcal.c
--- e:\wine\dlls\comctl32/monthcal.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/monthcal.c	2017-09-07 13:07:02 +0100
@@ -43,6 +43,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(monthcal);
 
+/* FIXME: Inspect */
+#define MCS_NOSELCHANGEONNAV 0x0100
+
 #define MC_SEL_LBUTUP	    1	/* Left button released */
 #define MC_SEL_LBUTDOWN	    2	/* Left button pressed in calendar */
 #define MC_PREVPRESSED      4   /* Prev month button pressed */
diff -pudN e:\wine\dlls\comctl32/propsheet.c e:\reactos\dll\win32\comctl32/propsheet.c
--- e:\wine\dlls\comctl32/propsheet.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/propsheet.c	2017-05-21 20:32:06 +0100
@@ -1176,8 +1176,13 @@ PROPSHEET_WizardSubclassProc(HWND hwnd, 
       return TRUE;
 
     case WM_CTLCOLORSTATIC:
+#ifdef __REACTOS__
+      SetBkMode((HDC)wParam, TRANSPARENT);
+      return (INT_PTR)GetStockObject(HOLLOW_BRUSH);
+#else
       SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
       return (INT_PTR)GetSysColorBrush(COLOR_WINDOW);
+#endif
   }
 
   return DefSubclassProc(hwnd, uMsg, wParam, lParam);
@@ -2440,12 +2445,19 @@ static void PROPSHEET_SetWizButtons(HWND
   HWND hwndFinish = GetDlgItem(hwndDlg, IDC_FINISH_BUTTON);
   BOOL enable_finish = ((dwFlags & PSWIZB_FINISH) || psInfo->hasFinish) && !(dwFlags & PSWIZB_DISABLEDFINISH);
 
+#ifdef __REACTOS__
+  HWND hwndCancel = GetDlgItem(hwndDlg, IDCANCEL);
+  INT iDefItem = 0;
+  HWND hwndFocus;
+#endif
+
   TRACE("%d\n", dwFlags);
 
   EnableWindow(hwndBack, dwFlags & PSWIZB_BACK);
   EnableWindow(hwndNext, dwFlags & PSWIZB_NEXT);
   EnableWindow(hwndFinish, enable_finish);
 
+#ifndef __REACTOS__
   /* set the default pushbutton to an enabled button */
   if (enable_finish)
     SendMessageW(hwndDlg, DM_SETDEFID, IDC_FINISH_BUTTON, 0);
@@ -2455,6 +2467,7 @@ static void PROPSHEET_SetWizButtons(HWND
     SendMessageW(hwndDlg, DM_SETDEFID, IDC_BACK_BUTTON, 0);
   else
     SendMessageW(hwndDlg, DM_SETDEFID, IDCANCEL, 0);
+#endif
 
   if (!psInfo->hasFinish)
   {
@@ -2474,6 +2487,25 @@ static void PROPSHEET_SetWizButtons(HWND
       ShowWindow(hwndNext, SW_SHOW);
     }
   }
+
+#ifdef __REACTOS__
+  /* set the default pushbutton to an enabled button */
+  if (((dwFlags & PSWIZB_FINISH) || psInfo->hasFinish) && !(dwFlags & PSWIZB_DISABLEDFINISH))
+    iDefItem = IDC_FINISH_BUTTON;
+  else if (dwFlags & PSWIZB_NEXT)
+    iDefItem = IDC_NEXT_BUTTON;
+  else if (dwFlags & PSWIZB_BACK)
+    iDefItem = IDC_BACK_BUTTON;
+  else
+    iDefItem = IDCANCEL;
+  SendMessageW(hwndDlg, DM_SETDEFID, iDefItem, 0);
+
+  /* Set focus if no control has it */
+  hwndFocus = GetFocus();
+  if (!hwndFocus || hwndFocus == hwndCancel)
+    SetFocus(GetDlgItem(hwndDlg, iDefItem));
+#endif
+
 }
 
 /******************************************************************************
@@ -3282,7 +3314,11 @@ static LRESULT PROPSHEET_Paint(HWND hwnd
 
         hOldFont = SelectObject(hdc, psInfo->hFontBold);
 
+#ifdef __REACTOS__
+        if (psInfo->ppshheader.u5.hbmHeader)
+#else
         if (psInfo->ppshheader.dwFlags & PSH_USEHBMHEADER)
+#endif
         {
             hbmp = SelectObject(hdcSrc, psInfo->ppshheader.u5.hbmHeader);
 
@@ -3357,7 +3393,11 @@ static LRESULT PROPSHEET_Paint(HWND hwnd
 	if (ppshpage->dwFlags & PSP_USEHEADERSUBTITLE) {
 	    SelectObject(hdc, psInfo->hFont);
 	    SetRect(&r, 40, 25, rzone.right - 69, rzone.bottom);
+#ifdef __REACTOS__
+            if (!IS_INTRESOURCE(ppshpage->pszHeaderSubTitle))
+#else
             if (!IS_INTRESOURCE(ppshpage->pszHeaderTitle))
+#endif
                 DrawTextW(hdc, ppshpage->pszHeaderSubTitle, -1, &r, DT_LEFT | DT_WORDBREAK);
 	    else
 	    {
@@ -3379,7 +3419,12 @@ static LRESULT PROPSHEET_Paint(HWND hwnd
 
     if ( (ppshpage && (ppshpage->dwFlags & PSP_HIDEHEADER)) &&
 	 (psInfo->ppshheader.dwFlags & (PSH_WIZARD97_OLD | PSH_WIZARD97_NEW)) &&
+#ifdef __REACTOS__
+	 (psInfo->ppshheader.dwFlags & PSH_WATERMARK) &&
+	 (psInfo->ppshheader.u4.hbmWatermark) ) 
+#else
 	 (psInfo->ppshheader.dwFlags & PSH_WATERMARK) ) 
+#endif
     {
 	HWND hwndLine = GetDlgItem(hwnd, IDC_SUNKEN_LINE);	    
 
diff -pudN e:\wine\dlls\comctl32/rebar.c e:\reactos\dll\win32\comctl32/rebar.c
--- e:\wine\dlls\comctl32/rebar.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/rebar.c	2017-05-07 14:47:57 +0100
@@ -50,7 +50,6 @@
  *   - WM_QUERYNEWPALETTE
  *   - WM_RBUTTONDOWN
  *   - WM_RBUTTONUP
- *   - WM_SYSCOLORCHANGE
  *   - WM_VKEYTOITEM
  *   - WM_WININICHANGE
  *   Notifications:
@@ -1819,16 +1818,43 @@ static LRESULT REBAR_EraseBkGnd (const R
     RECT cr;
     COLORREF old = CLR_NONE, new;
     HTHEME theme = GetWindowTheme (infoPtr->hwndSelf);
+#ifdef __REACTOS__
+    HRGN hrgn;
+#endif
 
     GetClientRect (infoPtr->hwndSelf, &cr);
 
+#ifdef __REACTOS__
+
+    if (theme)
+    {
+        if (IsThemeBackgroundPartiallyTransparent(theme, RP_BACKGROUND, 0))
+        {
+            DrawThemeParentBackground (infoPtr->hwndSelf, hdc, &cr);
+        }
+        DrawThemeBackground (theme, hdc, 0, 0, &cr, NULL);
+    }
+
+    hrgn = CreateRectRgn(cr.left, cr.top, cr.right, cr.bottom);
+
+#endif
+
     oldrow = -1;
     for(i=0; i<infoPtr->uNumBands; i++) {
         RECT rcBand;
+#ifdef __REACTOS__
+        RECT rcBandReal;
+        HRGN hrgnBand;
+#endif
+
         lpBand = REBAR_GetBand(infoPtr, i);
 	if (HIDDENBAND(lpBand)) continue;
         translate_rect(infoPtr, &rcBand, &lpBand->rcBand);
 
+#ifdef __REACTOS__
+        rcBandReal = rcBand;
+#endif
+
 	/* draw band separator between rows */
 	if (lpBand->iRow != oldrow) {
 	    oldrow = lpBand->iRow;
@@ -1853,6 +1879,9 @@ static LRESULT REBAR_EraseBkGnd (const R
 		}
                 TRACE ("drawing band separator bottom (%s)\n",
                        wine_dbgstr_rect(&rcRowSep));
+#ifdef __REACTOS__
+        rcBandReal = rcRowSep;
+#endif
 	    }
 	}
 
@@ -1863,6 +1892,9 @@ static LRESULT REBAR_EraseBkGnd (const R
 	    if (infoPtr->dwStyle & CCS_VERT) {
                 rcSep.bottom = rcSep.top;
 		rcSep.top -= SEP_WIDTH_SIZE;
+#ifdef __REACTOS__
+        rcBandReal.top -= SEP_WIDTH_SIZE;
+#endif
                 if (theme)
                     DrawThemeEdge (theme, hdc, RP_BAND, 0, &rcSep, EDGE_ETCHED, BF_BOTTOM, NULL);
                 else
@@ -1871,6 +1903,9 @@ static LRESULT REBAR_EraseBkGnd (const R
 	    else {
                 rcSep.right = rcSep.left;
 		rcSep.left -= SEP_WIDTH_SIZE;
+#ifdef __REACTOS__
+        rcBandReal.left -= SEP_WIDTH_SIZE;
+#endif
                 if (theme)
                     DrawThemeEdge (theme, hdc, RP_BAND, 0, &rcSep, EDGE_ETCHED, BF_RIGHT, NULL);
                 else
@@ -1901,6 +1936,9 @@ static LRESULT REBAR_EraseBkGnd (const R
 #endif
 	}
 
+#ifdef __REACTOS__
+        if (!theme)
+#else
         if (theme)
         {
             /* When themed, the background color is ignored (but not a
@@ -1908,6 +1946,7 @@ static LRESULT REBAR_EraseBkGnd (const R
             DrawThemeBackground (theme, hdc, 0, 0, &cr, &rcBand);
         }
         else
+#endif
         {
             old = SetBkColor (hdc, new);
             TRACE("%s background color=0x%06x, band %s\n",
@@ -1918,7 +1957,26 @@ static LRESULT REBAR_EraseBkGnd (const R
             if (lpBand->clrBack != CLR_NONE)
                 SetBkColor (hdc, old);
         }
+
+#ifdef __REACTOS__
+        hrgnBand = CreateRectRgn(rcBandReal.left, rcBandReal.top, rcBandReal.right, rcBandReal.bottom);
+        CombineRgn(hrgn, hrgn, hrgnBand, RGN_DIFF);
+        DeleteObject(hrgnBand);
+#endif
     }
+
+#if 1
+#ifdef __REACTOS__
+    if (!theme)
+#endif
+    {
+        //FIXME: Apparently painting the remaining area is a v6 feature
+        HBRUSH hbrush = CreateSolidBrush(new);
+        FillRgn(hdc, hrgn, hbrush);
+        DeleteObject(hbrush);
+    }
+    DeleteObject(hrgn);
+#endif
     return TRUE;
 }
 
@@ -2887,12 +2945,26 @@ REBAR_ShowBand (REBAR_INFO *infoPtr, INT
 
 
 static LRESULT
+#ifdef __REACTOS__
+REBAR_SizeToRect (REBAR_INFO *infoPtr, WPARAM flags, RECT *lpRect)
+#else
 REBAR_SizeToRect (REBAR_INFO *infoPtr, const RECT *lpRect)
+#endif
 {
     if (!lpRect) return FALSE;
 
     TRACE("[%s]\n", wine_dbgstr_rect(lpRect));
     REBAR_SizeToHeight(infoPtr, get_rect_cy(infoPtr, lpRect));
+
+#ifdef __REACTOS__
+    /* Note that this undocumented flag is available on comctl32 v6 or later */
+    if ((flags & RBSTR_CHANGERECT) != 0)
+    {
+        RECT rcRebar;
+        GetClientRect(infoPtr->hwndSelf, &rcRebar);
+        lpRect->bottom = lpRect->top + (rcRebar.bottom - rcRebar.top);
+    }
+#endif
     return TRUE;
 }
 
@@ -3199,7 +3271,11 @@ REBAR_NCCalcSize (const REBAR_INFO *info
     else if ((theme = GetWindowTheme (infoPtr->hwndSelf)))
     {
         /* FIXME: should use GetThemeInt */
+#ifdef __REACTOS__
+        rect->top = (rect->top + 1 < rect->bottom) ? rect->top : rect->bottom;
+#else
         rect->top = min(rect->top + 1, rect->bottom);
+#endif
     }
     TRACE("new client=(%s)\n", wine_dbgstr_rect(rect));
     return 0;
@@ -3300,7 +3376,11 @@ REBAR_NCHitTest (const REBAR_INFO *infoP
 			   (INT *)&nmmouse.dwItemSpec);
     nmmouse.dwItemData = 0;
     nmmouse.pt = clpt;
+#ifdef __REACTOS__
+    nmmouse.dwHitInfo = scrap;
+#else
     nmmouse.dwHitInfo = 0;
+#endif
     if ((i = REBAR_Notify((NMHDR *) &nmmouse, infoPtr, NM_NCHITTEST))) {
 	TRACE("notify changed return value from %ld to %d\n",
 	      ret, i);
@@ -3372,6 +3452,9 @@ REBAR_Paint (const REBAR_INFO *infoPtr, 
 {
     if (hdc) {
         TRACE("painting\n");
+#ifdef __REACTOS__
+        REBAR_EraseBkGnd (infoPtr, hdc);
+#endif
         REBAR_Refresh (infoPtr, hdc);
     } else {
         PAINTSTRUCT ps;
@@ -3650,7 +3733,11 @@ REBAR_WindowProc (HWND hwnd, UINT uMsg, 
 	    return REBAR_ShowBand (infoPtr, wParam, lParam);
 
 	case RB_SIZETORECT:
+#ifdef __REACTOS__
+	    return REBAR_SizeToRect (infoPtr, wParam, (LPRECT)lParam);
+#else
 	    return REBAR_SizeToRect (infoPtr, (LPCRECT)lParam);
+#endif
 
 
 /*    Messages passed to parent */
@@ -3733,6 +3820,11 @@ REBAR_WindowProc (HWND hwnd, UINT uMsg, 
 
         case WM_SYSCOLORCHANGE:
             COMCTL32_RefreshSysColors();
+#ifdef __REACTOS__
+            /* r51522 - Properly support WM_SYSCOLORCHANGE */
+            infoPtr->clrBtnText = comctl32_color.clrBtnText;
+            infoPtr->clrBtnFace = comctl32_color.clrBtnFace;
+#endif
             return 0;
 
 /*      case WM_VKEYTOITEM:     supported according to ControlSpy */
diff -pudN e:\wine\dlls\comctl32/syslink.c e:\reactos\dll\win32\comctl32/syslink.c
--- e:\wine\dlls\comctl32/syslink.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/syslink.c	2017-05-27 17:00:22 +0100
@@ -29,8 +29,6 @@
 
 #include "comctl32.h"
 
-#include <wine/list.h>
-
 WINE_DEFAULT_DEBUG_CHANNEL(syslink);
 
 typedef struct
diff -pudN e:\wine\dlls\comctl32/theme_button.c e:\reactos\dll\win32\comctl32/theme_button.c
--- e:\wine\dlls\comctl32/theme_button.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/theme_button.c	2017-08-11 22:11:08 +0100
@@ -34,7 +34,30 @@ typedef enum
 	STATE_DEFAULTED
 } ButtonState;
 
+#ifdef __REACTOS__ /* r73885 */
+typedef void (*pfThemedPaint)(HTHEME theme, HWND hwnd, HDC hdc, ButtonState drawState, UINT dtFlags, BOOL focused, LPARAM prfFlag);
+#else
 typedef void (*pfThemedPaint)(HTHEME theme, HWND hwnd, HDC hdc, ButtonState drawState, UINT dtFlags, BOOL focused);
+#endif
+
+#ifdef __REACTOS__ /* r73885 & r73907 */
+static inline LONG get_button_state( HWND hwnd )
+{
+    return _GetButtonData(hwnd)->state;
+}
+
+static inline HFONT get_button_font( HWND hwnd )
+{
+    return (HFONT)_GetButtonData(hwnd)->font;
+}
+
+static inline LONG_PTR get_button_image(HWND hwnd)
+{
+    return _GetButtonData(hwnd)->image;
+}
+
+BOOL BUTTON_DrawIml(HDC hdc, BUTTON_IMAGELIST *pimlData, RECT *prc, BOOL bOnlyCalc);
+#endif
 
 static UINT get_drawtext_flags(DWORD style, DWORD ex_style)
 {
@@ -87,22 +110,56 @@ static inline WCHAR *get_button_text(HWN
     return text;
 }
 
+#ifdef __REACTOS__ /* r73885 */
+static void PB_draw(HTHEME theme, HWND hwnd, HDC hDC, ButtonState drawState, UINT dtFlags, BOOL focused, LPARAM prfFlag)
+#else
 static void PB_draw(HTHEME theme, HWND hwnd, HDC hDC, ButtonState drawState, UINT dtFlags, BOOL focused)
+#endif
 {
     static const int states[] = { PBS_NORMAL, PBS_DISABLED, PBS_HOT, PBS_PRESSED, PBS_DEFAULTED };
 
     RECT bgRect, textRect;
+#ifdef __REACTOS__ /* r73885 */
+    HFONT font = get_button_font(hwnd);
+#else
     HFONT font = (HFONT)SendMessageW(hwnd, WM_GETFONT, 0, 0);
+#endif
     HFONT hPrevFont = font ? SelectObject(hDC, font) : NULL;
     int state = states[ drawState ];
     WCHAR *text = get_button_text(hwnd);
+#ifdef __REACTOS__ /* r74012 & r74406 */
+    PBUTTON_DATA pdata = _GetButtonData(hwnd);
+    HWND parent;
+    HBRUSH hBrush;
+#endif
 
     GetClientRect(hwnd, &bgRect);
     GetThemeBackgroundContentRect(theme, hDC, BP_PUSHBUTTON, state, &bgRect, &textRect);
 
+#ifdef __REACTOS__ /* r73885 & r74149 */
+    if (prfFlag == 0)
+    {
+        if (IsThemeBackgroundPartiallyTransparent(theme, BP_PUSHBUTTON, state))
+            DrawThemeParentBackground(hwnd, hDC, NULL);
+    }
+#else
     if (IsThemeBackgroundPartiallyTransparent(theme, BP_PUSHBUTTON, state))
         DrawThemeParentBackground(hwnd, hDC, NULL);
+#endif
+
+#ifdef __REACTOS__ /* r74406 */
+    parent = GetParent(hwnd);
+    if (!parent) parent = hwnd;
+    hBrush = (HBRUSH)SendMessageW( parent, WM_CTLCOLORBTN, (WPARAM)hDC, (LPARAM)hwnd );
+    FillRect( hDC, &bgRect, hBrush );
+#endif
+
     DrawThemeBackground(theme, hDC, BP_PUSHBUTTON, state, &bgRect, NULL);
+
+#ifdef __REACTOS__ /* r74012 */
+    BUTTON_DrawIml(hDC, &pdata->imlData, &textRect, FALSE);
+#endif
+
     if (text)
     {
         DrawThemeText(theme, hDC, BP_PUSHBUTTON, state, text, lstrlenW(text), dtFlags, 0, &textRect);
@@ -127,7 +184,11 @@ static void PB_draw(HTHEME theme, HWND h
     if (hPrevFont) SelectObject(hDC, hPrevFont);
 }
 
+#ifdef __REACTOS__ /* r73885 */
+static void CB_draw(HTHEME theme, HWND hwnd, HDC hDC, ButtonState drawState, UINT dtFlags, BOOL focused, LPARAM prfFlag)
+#else
 static void CB_draw(HTHEME theme, HWND hwnd, HDC hDC, ButtonState drawState, UINT dtFlags, BOOL focused)
+#endif
 {
     static const int cb_states[3][5] =
     {
@@ -145,7 +206,11 @@ static void CB_draw(HTHEME theme, HWND h
     SIZE sz;
     RECT bgRect, textRect;
     HFONT font, hPrevFont = NULL;
+#ifdef __REACTOS__ /* r73885 */
+    LRESULT checkState = get_button_state(hwnd) & 3;
+#else
     LRESULT checkState = SendMessageW(hwnd, BM_GETCHECK, 0, 0);
+#endif
     DWORD dwStyle = GetWindowLongW(hwnd, GWL_STYLE);
     int part = ((dwStyle & BUTTON_TYPE) == BS_RADIOBUTTON) || ((dwStyle & BUTTON_TYPE) == BS_AUTORADIOBUTTON)
              ? BP_RADIOBUTTON
@@ -156,6 +221,10 @@ static void CB_draw(HTHEME theme, HWND h
     WCHAR *text = get_button_text(hwnd);
     LOGFONTW lf;
     BOOL created_font = FALSE;
+#ifdef __REACTOS__ /* r74406 */
+    HWND parent;
+    HBRUSH hBrush;
+#endif
 
     HRESULT hr = GetThemeFont(theme, hDC, part, state, TMT_FONT, &lf);
     if (SUCCEEDED(hr)) {
@@ -168,7 +237,11 @@ static void CB_draw(HTHEME theme, HWND h
             created_font = TRUE;
         }
     } else {
+#ifdef __REACTOS__ /* r73885 */
+        font = get_button_font(hwnd);
+#else
         font = (HFONT)SendMessageW(hwnd, WM_GETFONT, 0, 0);
+#endif
         hPrevFont = SelectObject(hDC, font);
     }
 
@@ -176,6 +249,23 @@ static void CB_draw(HTHEME theme, HWND h
         sz.cx = sz.cy = 13;
 
     GetClientRect(hwnd, &bgRect);
+
+#ifdef __REACTOS__ /* r73885, r74149 and r74406 */
+    if (prfFlag == 0)
+    {
+        DrawThemeParentBackground(hwnd, hDC, NULL);
+    }
+
+    parent = GetParent(hwnd);
+    if (!parent) parent = hwnd;
+    hBrush = (HBRUSH)SendMessageW(parent, WM_CTLCOLORSTATIC,
+                                 (WPARAM)hDC, (LPARAM)hwnd);
+    if (!hBrush) /* did the app forget to call defwindowproc ? */
+        hBrush = (HBRUSH)DefWindowProcW(parent, WM_CTLCOLORSTATIC,
+                                        (WPARAM)hDC, (LPARAM)hwnd );
+    FillRect( hDC, &bgRect, hBrush );
+#endif
+
     GetThemeBackgroundContentRect(theme, hDC, part, state, &bgRect, &textRect);
 
     if (dtFlags & DT_SINGLELINE) /* Center the checkbox / radio button to the text. */
@@ -186,7 +276,9 @@ static void CB_draw(HTHEME theme, HWND h
     bgRect.right = bgRect.left + sz.cx;
     textRect.left = bgRect.right + 6;
 
+#ifndef __REACTOS__ /* r74406 */
     DrawThemeParentBackground(hwnd, hDC, NULL);
+#endif
 
     DrawThemeBackground(theme, hDC, part, state, &bgRect, NULL);
     if (text)
@@ -214,7 +306,11 @@ static void CB_draw(HTHEME theme, HWND h
     if (hPrevFont) SelectObject(hDC, hPrevFont);
 }
 
+#ifdef __REACTOS__ /* r73885 */
+static void GB_draw(HTHEME theme, HWND hwnd, HDC hDC, ButtonState drawState, UINT dtFlags, BOOL focused, LPARAM prfFlag)
+#else
 static void GB_draw(HTHEME theme, HWND hwnd, HDC hDC, ButtonState drawState, UINT dtFlags, BOOL focused)
+#endif
 {
     static const int states[] = { GBS_NORMAL, GBS_DISABLED, GBS_NORMAL, GBS_NORMAL, GBS_NORMAL };
 
@@ -224,6 +320,11 @@ static void GB_draw(HTHEME theme, HWND h
     LOGFONTW lf;
     HFONT font, hPrevFont = NULL;
     BOOL created_font = FALSE;
+#ifdef __REACTOS__ /* r74406 */
+    HWND parent;
+    HBRUSH hBrush;
+    RECT clientRect;
+#endif
 
     HRESULT hr = GetThemeFont(theme, hDC, BP_GROUPBOX, state, TMT_FONT, &lf);
     if (SUCCEEDED(hr)) {
@@ -235,7 +336,11 @@ static void GB_draw(HTHEME theme, HWND h
             created_font = TRUE;
         }
     } else {
+#ifdef __REACTOS__ /* r73885 */
+        font = get_button_font(hwnd);
+#else
         font = (HFONT)SendMessageW(hwnd, WM_GETFONT, 0, 0);
+#endif
         hPrevFont = SelectObject(hDC, font);
     }
 
@@ -257,8 +362,29 @@ static void GB_draw(HTHEME theme, HWND h
     GetThemeBackgroundContentRect(theme, hDC, BP_GROUPBOX, state, &bgRect, &contentRect);
     ExcludeClipRect(hDC, contentRect.left, contentRect.top, contentRect.right, contentRect.bottom);
 
+#ifdef __REACTOS__ /* r73885 & r74149 */
+    if (prfFlag == 0)
+    {
+        if (IsThemeBackgroundPartiallyTransparent(theme, BP_GROUPBOX, state))
+            DrawThemeParentBackground(hwnd, hDC, NULL);
+    }
+#else
     if (IsThemeBackgroundPartiallyTransparent(theme, BP_GROUPBOX, state))
         DrawThemeParentBackground(hwnd, hDC, NULL);
+#endif
+
+#ifdef __REACTOS__ /* r74406 */
+    parent = GetParent(hwnd);
+    if (!parent) parent = hwnd;
+    hBrush = (HBRUSH)SendMessageW(parent, WM_CTLCOLORSTATIC,
+                                  (WPARAM)hDC, (LPARAM)hwnd);
+    if (!hBrush) /* did the app forget to call defwindowproc ? */
+        hBrush = (HBRUSH)DefWindowProcW(parent, WM_CTLCOLORSTATIC,
+                                       (WPARAM)hDC, (LPARAM)hwnd );
+    GetClientRect(hwnd, &clientRect);
+    FillRect( hDC, &clientRect, hBrush );
+#endif
+
     DrawThemeBackground(theme, hDC, BP_GROUPBOX, state, &bgRect, NULL);
 
     SelectClipRgn(hDC, NULL);
@@ -294,32 +420,84 @@ static const pfThemedPaint btnThemedPain
     NULL, /* Not defined */
 };
 
+#ifdef __REACTOS__ /* r73873 */
+BOOL BUTTON_PaintWithTheme(HTHEME theme, HWND hwnd, HDC hParamDC, LPARAM prfFlag)
+#else
 static BOOL BUTTON_Paint(HTHEME theme, HWND hwnd, HDC hParamDC)
+#endif
 {
+#ifdef __REACTOS__ /* r73873, r73897 and r74120 */
+    DWORD dwStyle;
+    DWORD dwStyleEx;
+    DWORD type;
+    UINT dtFlags;
+    int state;
+#else
     PAINTSTRUCT ps;
     HDC hDC;
     DWORD dwStyle = GetWindowLongW(hwnd, GWL_STYLE);
     DWORD dwStyleEx = GetWindowLongW(hwnd, GWL_EXSTYLE);
     UINT dtFlags = get_drawtext_flags(dwStyle, dwStyleEx);
     int state = (int)SendMessageW(hwnd, BM_GETSTATE, 0, 0);
+#endif
     ButtonState drawState;
+#ifdef __REACTOS__ /* r73873, r73897, r73907 and r74120 */
+    pfThemedPaint paint;
+
+    dwStyle = GetWindowLongW(hwnd, GWL_STYLE);
+    type = dwStyle & BUTTON_TYPE;
+
+    if (type != BS_PUSHBUTTON && type != BS_DEFPUSHBUTTON && (dwStyle & BS_PUSHLIKE))
+        type = BS_PUSHBUTTON;
+
+    paint = btnThemedPaintFunc[type];
+    if (!paint)
+        return FALSE;
+
+    if (get_button_image(hwnd) != 0)
+        return FALSE;
+
+    dwStyleEx = GetWindowLongW(hwnd, GWL_EXSTYLE);
+    dtFlags = get_drawtext_flags(dwStyle, dwStyleEx);
+    state = get_button_state(hwnd);
+#else
     pfThemedPaint paint = btnThemedPaintFunc[ dwStyle & BUTTON_TYPE ];
+#endif
 
     if(IsWindowEnabled(hwnd))
     {
-        if(state & BST_PUSHED) drawState = STATE_PRESSED;
-        else if(state & BST_HOT) drawState = STATE_HOT;
-        else if(state & BST_FOCUS) drawState = STATE_DEFAULTED;
-        else drawState = STATE_NORMAL;
+        if(state & BST_PUSHED) 
+            drawState = STATE_PRESSED;
+        else if ((dwStyle & BS_PUSHLIKE) && (state & (BST_CHECKED|BST_INDETERMINATE))) 
+            drawState = STATE_PRESSED;
+        else if(state & BST_HOT) 
+            drawState = STATE_HOT;
+        else if(state & BST_FOCUS) 
+            drawState = STATE_DEFAULTED;
+        else 
+            drawState = STATE_NORMAL;
     }
-    else drawState = STATE_DISABLED;
+    else 
+        drawState = STATE_DISABLED;
 
+#ifndef __REACTOS__ /* r73873 */
     hDC = hParamDC ? hParamDC : BeginPaint(hwnd, &ps);
     if (paint) paint(theme, hwnd, hDC, drawState, dtFlags, state & BST_FOCUS);
     if (!hParamDC) EndPaint(hwnd, &ps);
+#endif
+
+#ifdef __REACTOS__ /* r74074 & r74120 */
+    if (drawState == STATE_NORMAL && type == BS_DEFPUSHBUTTON)
+    {
+        drawState = STATE_DEFAULTED;
+    }
+#endif
+
+    paint(theme, hwnd, hParamDC, drawState, dtFlags, state & BST_FOCUS, prfFlag);
     return TRUE;
 }
 
+#ifndef __REACTOS__ /* r73873 */
 /**********************************************************************
  * The button control subclass window proc.
  */
@@ -416,3 +594,4 @@ LRESULT CALLBACK THEMING_ButtonSubclassP
     }
     return 0;
 }
+#endif /* !__REACTOS__ */
diff -pudN e:\wine\dlls\comctl32/theme_edit.c e:\reactos\dll\win32\comctl32/theme_edit.c
--- e:\wine\dlls\comctl32/theme_edit.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/theme_edit.c	2017-05-21 20:36:43 +0100
@@ -52,8 +52,15 @@ static void nc_paint (HTHEME theme, HWND
             CombineRgn (cliprgn, cliprgn, region, RGN_AND);
         OffsetRect(&r, -r.left, -r.top);
     
+#ifdef __REACTOS__ /* r73789 */
+        dc = GetWindowDC(hwnd);
+        /* Exclude client part */
+        ExcludeClipRect(dc, r.left + cxEdge, r.top + cyEdge,
+            r.right - cxEdge, r.bottom -cyEdge);
+#else
         dc = GetDCEx(hwnd, region, DCX_WINDOW|DCX_INTERSECTRGN);
         OffsetRect(&r, -r.left, -r.top);
+#endif
     
         if (IsThemeBackgroundPartiallyTransparent (theme, part, state))
             DrawThemeParentBackground(hwnd, dc, &r);
diff -pudN e:\wine\dlls\comctl32/theme_listbox.c e:\reactos\dll\win32\comctl32/theme_listbox.c
--- e:\wine\dlls\comctl32/theme_listbox.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/theme_listbox.c	2017-05-21 20:37:26 +0100
@@ -42,8 +42,15 @@ static void nc_paint (HTHEME theme, HWND
             CombineRgn (cliprgn, cliprgn, region, RGN_AND);
         OffsetRect(&r, -r.left, -r.top);
     
+#ifdef __REACTOS__ /* r73789 */
+        dc = GetWindowDC(hwnd);
+        /* Exclude client part */
+        ExcludeClipRect(dc, r.left + cxEdge, r.top + cyEdge,
+            r.right - cxEdge, r.bottom -cyEdge);
+#else
         dc = GetDCEx(hwnd, region, DCX_WINDOW|DCX_INTERSECTRGN);
         OffsetRect(&r, -r.left, -r.top);
+#endif
     
         if (IsThemeBackgroundPartiallyTransparent (theme, 0, 0))
             DrawThemeParentBackground(hwnd, dc, &r);
diff -pudN e:\wine\dlls\comctl32/theming.c e:\reactos\dll\win32\comctl32/theming.c
--- e:\wine\dlls\comctl32/theming.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/theming.c	2017-05-21 20:45:56 +0100
@@ -26,12 +26,16 @@ WINE_DEFAULT_DEBUG_CHANNEL(theming);
 typedef LRESULT (CALLBACK* THEMING_SUBCLASSPROC)(HWND, UINT, WPARAM, LPARAM,
     ULONG_PTR);
 
+#ifndef __REACTOS__ /* r73871 */
 extern LRESULT CALLBACK THEMING_ButtonSubclassProc (HWND, UINT, WPARAM, LPARAM,
                                                     ULONG_PTR) DECLSPEC_HIDDEN;
+#endif
 extern LRESULT CALLBACK THEMING_ComboSubclassProc (HWND, UINT, WPARAM, LPARAM,
                                                    ULONG_PTR) DECLSPEC_HIDDEN;
+#ifndef __REACTOS__ /* r73803 */
 extern LRESULT CALLBACK THEMING_DialogSubclassProc (HWND, UINT, WPARAM, LPARAM,
                                                     ULONG_PTR) DECLSPEC_HIDDEN;
+#endif
 extern LRESULT CALLBACK THEMING_EditSubclassProc (HWND, UINT, WPARAM, LPARAM,
                                                   ULONG_PTR) DECLSPEC_HIDDEN;
 extern LRESULT CALLBACK THEMING_ListBoxSubclassProc (HWND, UINT, WPARAM, LPARAM,
@@ -48,8 +52,10 @@ static const struct ThemingSubclass
     THEMING_SUBCLASSPROC subclassProc;
 } subclasses[] = {
     /* Note: list must be sorted by class name */
+#ifndef __REACTOS__ /* r73803 & r73871 */
     {dialogClass,          THEMING_DialogSubclassProc},
     {WC_BUTTONW,           THEMING_ButtonSubclassProc},
+#endif
     {WC_COMBOBOXW,         THEMING_ComboSubclassProc},
     {comboLboxClass,       THEMING_ListBoxSubclassProc},
     {WC_EDITW,             THEMING_EditSubclassProc},
@@ -89,17 +95,23 @@ MAKE_SUBCLASS_PROC(1)
 MAKE_SUBCLASS_PROC(2)
 MAKE_SUBCLASS_PROC(3)
 MAKE_SUBCLASS_PROC(4)
+#ifndef __REACTOS__ /* r73803 & r73871 */
 MAKE_SUBCLASS_PROC(5)
 MAKE_SUBCLASS_PROC(6)
+#endif
 
 static const WNDPROC subclassProcs[NUM_SUBCLASSES] = {
     subclass_proc0,
     subclass_proc1,
     subclass_proc2,
     subclass_proc3,
+#ifdef __REACTOS__ /* r73871 */
+    subclass_proc4
+#else
     subclass_proc4,
     subclass_proc5,
     subclass_proc6
+#endif
 };
 
 /***********************************************************************
@@ -108,15 +120,23 @@ static const WNDPROC subclassProcs[NUM_S
  * Register classes for standard controls that will shadow the system
  * classes.
  */
+#ifdef __REACTOS__ /* r73803 */
+void THEMING_Initialize(HANDLE hActCtx5, HANDLE hActCtx6)
+#else
 void THEMING_Initialize (void)
+#endif
 {
     unsigned int i;
     static const WCHAR subclassPropName[] = 
         { 'C','C','3','2','T','h','e','m','i','n','g','S','u','b','C','l',0 };
     static const WCHAR refDataPropName[] = 
         { 'C','C','3','2','T','h','e','m','i','n','g','D','a','t','a',0 };
-
+#ifdef __REACTOS__ /* r73803 */
+    ULONG_PTR ulCookie;
+    BOOL ret, bActivated;
+#else
     if (!IsThemeActive()) return;
+#endif
 
     atSubclassProp = GlobalAddAtomW (subclassPropName);
     atRefDataProp = GlobalAddAtomW (refDataPropName);
@@ -126,7 +146,17 @@ void THEMING_Initialize (void)
         WNDCLASSEXW class;
 
         class.cbSize = sizeof(class);
+
+#ifdef __REACTOS__ /* r73803 */
+        bActivated = ActivateActCtx(hActCtx5, &ulCookie);
+        ret = GetClassInfoExW (NULL, subclasses[i].className, &class);
+        if (bActivated)
+            DeactivateActCtx(0, ulCookie);
+
+        if (!ret)
+#else
         if (!GetClassInfoExW (NULL, subclasses[i].className, &class))
+#endif
         {
             ERR("Could not retrieve information for class %s\n",
                 debugstr_w (subclasses[i].className));
@@ -134,6 +164,10 @@ void THEMING_Initialize (void)
         }
         originalProcs[i] = class.lpfnWndProc;
         class.lpfnWndProc = subclassProcs[i];
+#ifdef __REACTOS__ /* r73803 */
+        class.style |= CS_GLOBALCLASS;
+        class.hInstance = COMCTL32_hModule;
+#endif
         
         if (!class.lpfnWndProc)
         {
@@ -142,9 +176,16 @@ void THEMING_Initialize (void)
             continue;
         }
 
+#ifdef __REACTOS__ /* r73803 */
+        bActivated = ActivateActCtx(hActCtx6, &ulCookie);
+#endif
         if (!RegisterClassExW (&class))
         {
+#ifdef __REACTOS__ /* r73803 */
+            WARN("Could not re-register class %s: %x\n",
+#else
             ERR("Could not re-register class %s: %x\n",
+#endif
                 debugstr_w (subclasses[i].className), GetLastError ());
         }
         else
@@ -152,6 +193,11 @@ void THEMING_Initialize (void)
             TRACE("Re-registered class %s\n", 
                 debugstr_w (subclasses[i].className));
         }
+
+#ifdef __REACTOS__ /* r73803 */
+        if (bActivated)
+            DeactivateActCtx(0, ulCookie);
+#endif
     }
 }
 
diff -pudN e:\wine\dlls\comctl32/toolbar.c e:\reactos\dll\win32\comctl32/toolbar.c
--- e:\wine\dlls\comctl32/toolbar.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/toolbar.c	2017-08-04 10:44:05 +0100
@@ -33,11 +33,9 @@
  *     - TBSTYLE_REGISTERDROP
  *     - TBSTYLE_EX_DOUBLEBUFFER
  *   - Messages:
- *     - TB_GETMETRICS
  *     - TB_GETOBJECT
  *     - TB_INSERTMARKHITTEST
  *     - TB_SAVERESTORE
- *     - TB_SETMETRICS
  *     - WM_WININICHANGE
  *   - Notifications:
  *     - NM_CHAR
@@ -125,6 +123,11 @@ typedef struct
     INT      nOldHit;
     INT      nHotItem;        /* index of the "hot" item */
     SIZE     szPadding;       /* padding values around button */
+#ifdef __REACTOS__
+    SIZE     szBarPadding;       /* padding values around the toolbar (NOT USED BUT STORED) */
+    SIZE     szSpacing;       /* spacing values between buttons */
+    MARGINS  themeMargins;
+#endif
     INT      iTopMargin;      /* the top margin */
     INT      iListGap;        /* default gap between text and image for toolbar with list style */
     HFONT    hDefaultFont;
@@ -190,12 +193,24 @@ typedef enum
 #define ARROW_HEIGHT       3
 #define INSERTMARK_WIDTH   2
 
+/* default padding inside a button */
 #define DEFPAD_CX 7
 #define DEFPAD_CY 6
+
+#ifdef __REACTOS__
+/* default space between buttons and between rows */
+#define DEFSPACE_CX 7
+#define DEFSPACE_CY 6
+#endif
+
 #define DEFLISTGAP 4
 
 /* vertical padding used in list mode when image is present */
+#ifdef __REACTOS__
+#define LISTPAD_CY 2
+#else
 #define LISTPAD_CY 9
+#endif
 
 /* how wide to treat the bitmap if it isn't present */
 #define NONLIST_NOTEXT_OFFSET 2
@@ -239,6 +254,10 @@ static LRESULT TOOLBAR_SetButtonInfo(TOO
 
 static inline int default_top_margin(const TOOLBAR_INFO *infoPtr)
 {
+#ifdef __REACTOS__
+    if (infoPtr->iVersion == 6)
+        return 0;
+#endif
     return (infoPtr->dwStyle & TBSTYLE_FLAT ? 0 : TOP_BORDER);
 }
 
@@ -598,6 +617,9 @@ TOOLBAR_DrawString (const TOOLBAR_INFO *
     COLORREF clrOldBk = 0;
     int oldBkMode = 0;
     UINT state = tbcd->nmcd.uItemState;
+#ifdef __REACTOS__
+    HTHEME theme = GetWindowTheme (infoPtr->hwndSelf);
+#endif
 
     /* draw text */
     if (lpText && infoPtr->nMaxTextRows > 0) {
@@ -627,6 +649,25 @@ TOOLBAR_DrawString (const TOOLBAR_INFO *
 	    clrOld = SetTextColor (hdc, tbcd->clrText);
 	}
 
+#ifdef __REACTOS__
+    if (theme)
+    {
+        int partId = TP_BUTTON;
+        int stateId = TS_NORMAL;
+
+        if (state & CDIS_DISABLED)
+            stateId = TS_DISABLED;
+        else if (state & CDIS_SELECTED)
+            stateId = TS_PRESSED;
+        else if (state & CDIS_CHECKED)
+            stateId = (state & CDIS_HOT) ? TS_HOTCHECKED : TS_HOT;
+        else if (state & CDIS_HOT)
+            stateId = TS_HOT;
+
+        DrawThemeText(theme, hdc, partId, stateId, lpText, -1, infoPtr->dwDTFlags, 0, rcText);
+    }
+    else
+#endif
 	DrawTextW (hdc, lpText, -1, rcText, infoPtr->dwDTFlags);
 	SetTextColor (hdc, clrOld);
 	if ((state & CDIS_MARKED) && !(dwItemCDFlag & TBCDRF_NOMARK))
@@ -723,10 +764,14 @@ TOOLBAR_DrawImage(const TOOLBAR_INFO *in
                   const NMTBCUSTOMDRAW *tbcd, DWORD dwItemCDFlag)
 {
     HIMAGELIST himl = NULL;
-    BOOL draw_masked = FALSE;
+    BOOL draw_masked = FALSE, draw_desaturated = FALSE;
     INT index;
     INT offset = 0;
     UINT draw_flags = ILD_TRANSPARENT;
+#ifdef __REACTOS__
+    IMAGEINFO info = {0};
+    BITMAP bm = {0};
+#endif
 
     if (tbcd->nmcd.uItemState & (CDIS_DISABLED | CDIS_INDETERMINATE))
     {
@@ -734,7 +779,22 @@ TOOLBAR_DrawImage(const TOOLBAR_INFO *in
         if (!himl)
         {
             himl = TOOLBAR_GetImageListForDrawing(infoPtr, btnPtr, IMAGE_LIST_DEFAULT, &index);
+
+#ifdef __REACTOS__
+            ImageList_GetImageInfo(himl, index, &info);
+            GetObjectW(info.hbmImage, sizeof(bm), &bm);
+
+            if (bm.bmBitsPixel == 32)
+            {
+                draw_desaturated = TRUE;
+            }
+            else
+            {
+                draw_masked = TRUE;
+            }
+#else
             draw_masked = TRUE;
+#endif
         }
     }
     else if (tbcd->nmcd.uItemState & CDIS_CHECKED ||
@@ -765,9 +825,34 @@ TOOLBAR_DrawImage(const TOOLBAR_INFO *in
       index, himl, left, top, offset);
 
     if (draw_masked)
+    {
+        /* code path for drawing flat disabled icons without alpha channel */
         TOOLBAR_DrawMasked (himl, index, tbcd->nmcd.hdc, left + offset, top + offset, draw_flags);
+    }
+    else if (draw_desaturated)
+    {
+        /* code path for drawing disabled, alpha-blended (32bpp) icons */
+        IMAGELISTDRAWPARAMS imldp = {0};
+
+        imldp.cbSize = sizeof(imldp);
+        imldp.himl   = himl;
+        imldp.i      = index;
+        imldp.hdcDst = tbcd->nmcd.hdc,
+        imldp.x      = offset + left;
+        imldp.y      = offset + top;
+        imldp.rgbBk  = CLR_NONE;
+        imldp.rgbFg  = CLR_DEFAULT;
+        imldp.fStyle = ILD_TRANSPARENT;
+        imldp.fState = ILS_ALPHA | ILS_SATURATE;
+        imldp.Frame  = 192;
+
+        ImageList_DrawIndirect (&imldp);
+    }
     else
+    {
+        /* code path for drawing standard icons as-is */
         ImageList_Draw (himl, index, tbcd->nmcd.hdc, left + offset, top + offset, draw_flags);
+    }
 }
 
 /* draws a blank frame for a toolbar button */
@@ -884,14 +969,15 @@ TOOLBAR_DrawButton (const TOOLBAR_INFO *
                 InflateRect(&rcsep, -infoPtr->szPadding.cx, -infoPtr->szPadding.cy);
                 TOOLBAR_DrawFlatHorizontalSeparator (&rcsep, hdc, infoPtr);
             }
-	    else
-		TOOLBAR_DrawFlatSeparator (&rc, hdc, infoPtr);
-	}
-	else if (btnPtr->fsStyle != BTNS_SEP) {
-	    FIXME("Draw some kind of separator: fsStyle=%x\n",
-		  btnPtr->fsStyle);
-	}
-	return;
+            else {
+                TOOLBAR_DrawFlatSeparator (&rc, hdc, infoPtr);
+            }
+        }

+        else if (btnPtr->fsStyle != BTNS_SEP) {
+            FIXME("Draw some kind of separator: fsStyle=%x\n",
+              btnPtr->fsStyle);
+        }
+        return;
     }
 
     /* get a pointer to the text */
@@ -933,6 +1019,9 @@ TOOLBAR_DrawButton (const TOOLBAR_INFO *
         rcBitmap.left += ((rc.right - rc.left) - infoPtr->nBitmapWidth) / 2;
 
     rcBitmap.top += infoPtr->szPadding.cy / 2;
+#ifdef __REACTOS__
+    rcBitmap.top += infoPtr->themeMargins.cyTopHeight;
+#endif
 
     TRACE("iBitmap=%d, start=(%d,%d) w=%d, h=%d\n",
       btnPtr->iBitmap, rcBitmap.left, rcBitmap.top,
@@ -1027,7 +1116,11 @@ TOOLBAR_DrawButton (const TOOLBAR_INFO *
         }
     }
 
+#ifdef __REACTOS__
+    if (theme && !(dwItemCDFlag & TBCDRF_NOBACKGROUND))
+#else
     if (theme)
+#endif
     {
         int partId = drawSepDropDownArrow ? TP_SPLITBUTTON : TP_BUTTON;
         int stateId = TS_NORMAL;
@@ -1044,7 +1137,12 @@ TOOLBAR_DrawButton (const TOOLBAR_INFO *
             
         DrawThemeBackground (theme, hdc, partId, stateId, &rc, NULL);
     }
+
+#ifdef __REACTOS__
+    if (!theme)
+#else
     else
+#endif
         TOOLBAR_DrawFrame(infoPtr, &tbcd, &rc, dwItemCDFlag);
 
     if (drawSepDropDownArrow)
@@ -1570,9 +1668,14 @@ static inline SIZE TOOLBAR_MeasureButton
         /* ... add on the necessary padding */
         if (bValidImageList)
         {
+#ifdef __REACTOS__
+            sizeButton.cy += infoPtr->szPadding.cy;
+            if (!bHasBitmap)
+#else
             if (bHasBitmap)
                 sizeButton.cy += DEFPAD_CY;
             else
+#endif
                 sizeButton.cy += LISTPAD_CY;
         }
         else
@@ -1589,7 +1692,11 @@ static inline SIZE TOOLBAR_MeasureButton
     {
         if (bHasBitmap)
         {
+#ifdef __REACTOS__
+            sizeButton.cy = infoPtr->nBitmapHeight + infoPtr->szPadding.cy;
+#else
             sizeButton.cy = infoPtr->nBitmapHeight + DEFPAD_CY;
+#endif
             if (sizeString.cy > 0)
                 sizeButton.cy += 1 + sizeString.cy;
             sizeButton.cx = infoPtr->szPadding.cx +
@@ -1603,6 +1710,12 @@ static inline SIZE TOOLBAR_MeasureButton
                 max(2*GetSystemMetrics(SM_CXEDGE) + sizeString.cx, infoPtr->nBitmapWidth);
         }
     }
+
+#ifdef __REACTOS__
+    sizeButton.cx += infoPtr->themeMargins.cxLeftWidth + infoPtr->themeMargins.cxRightWidth;
+    sizeButton.cy += infoPtr->themeMargins.cyTopHeight + infoPtr->themeMargins.cyBottomHeight;
+#endif
+
     return sizeButton;
 }
 
@@ -1695,7 +1808,14 @@ TOOLBAR_LayoutToolbar(TOOLBAR_INFO *info
 	{
             if (btnPtr->cx)
               cx = btnPtr->cx;
+#ifdef __REACTOS__
+            /* Revert Wine Commit 5b7b911 as it breaks Explorer Toolbar Buttons
+               FIXME: Revisit this when the bug is fixed. CORE-9970 */
+            else if ((infoPtr->dwExStyle & TBSTYLE_EX_MIXEDBUTTONS) || 
+                (btnPtr->fsStyle & BTNS_AUTOSIZE))
+#else
             else if (btnPtr->fsStyle & BTNS_AUTOSIZE)
+#endif
             {
               SIZE sz;
 	      HDC hdc;
@@ -1747,14 +1867,14 @@ TOOLBAR_LayoutToolbar(TOOLBAR_INFO *info
 	if( bWrap )
 	{
 	    if ( !(btnPtr->fsStyle & BTNS_SEP) )
-	        y += cy;
+	        y += cy + infoPtr->szSpacing.cy;
 	    else
 	    {
                if ( !(infoPtr->dwStyle & CCS_VERT))
                     y += cy + ( (btnPtr->cx > 0 ) ?
                                 btnPtr->cx : SEPARATOR_WIDTH) * 2 /3;
 		else
-		    y += cy;
+		    y += cy + infoPtr->szSpacing.cy;
 
 		/* nSepRows is used to calculate the extra height following  */
 		/* the last row.					     */
@@ -1768,7 +1888,7 @@ TOOLBAR_LayoutToolbar(TOOLBAR_INFO *info
 		nRows++;
 	}
 	else
-	    x += cx;
+	    x += cx + infoPtr->szSpacing.cx;
     }
 
     /* infoPtr->nRows is the number of rows on the toolbar */
@@ -3540,6 +3660,34 @@ TOOLBAR_GetMaxSize (const TOOLBAR_INFO *
     return TRUE;
 }
 
+#ifdef __REACTOS__
+static LRESULT
+TOOLBAR_GetMetrics(const TOOLBAR_INFO *infoPtr, TBMETRICS *pMetrics)
+{
+    if (pMetrics == NULL || pMetrics->cbSize != sizeof(TBMETRICS))
+        return 0;
+
+    if (pMetrics->dwMask & TBMF_PAD)
+    {
+        pMetrics->cxPad = infoPtr->szPadding.cx;
+        pMetrics->cyPad = infoPtr->szPadding.cy;
+    }
+
+    if (pMetrics->dwMask & TBMF_BARPAD)
+    {
+        pMetrics->cxBarPad = infoPtr->szBarPadding.cx;
+        pMetrics->cyBarPad = infoPtr->szBarPadding.cy;
+    }
+
+    if (pMetrics->dwMask & TBMF_BUTTONSPACING)
+    {
+        pMetrics->cxButtonSpacing = infoPtr->szSpacing.cx;
+        pMetrics->cyButtonSpacing = infoPtr->szSpacing.cy;
+    }
+
+    return 0;
+}
+#endif
 
 /* << TOOLBAR_GetObject >> */
 
@@ -4337,7 +4485,7 @@ TOOLBAR_SetBitmapSize (TOOLBAR_INFO *inf
     short width = (short)LOWORD(lParam);
     short height = (short)HIWORD(lParam);
 
-    TRACE("hwnd=%p, wParam=%ld, size %d x %d\n", infoPtr->hwndSelf, wParam, width, height);
+    TRACE("hwnd=%p, wParam=%ld, lParam=%ld\n", infoPtr->hwndSelf, wParam, lParam);
 
     if (wParam != 0)
         FIXME("wParam is %ld. Perhaps image list index?\n", wParam);
@@ -4455,8 +4603,13 @@ TOOLBAR_SetButtonSize (TOOLBAR_INFO *inf
     if (cx == 0) cx = 24;
     if (cy == 0) cy = 22;
 
+#ifdef __REACTOS__
+    cx = max(cx, infoPtr->szPadding.cx + infoPtr->nBitmapWidth + infoPtr->themeMargins.cxLeftWidth + infoPtr->themeMargins.cxRightWidth);
+    cy = max(cy, infoPtr->szPadding.cy + infoPtr->nBitmapHeight + infoPtr->themeMargins.cyTopHeight + infoPtr->themeMargins.cyBottomHeight);
+#else
     cx = max(cx, infoPtr->szPadding.cx + infoPtr->nBitmapWidth);
     cy = max(cy, infoPtr->szPadding.cy + infoPtr->nBitmapHeight);
+#endif
 
     if (cx != infoPtr->nButtonWidth || cy != infoPtr->nButtonHeight ||
         top != infoPtr->iTopMargin)
@@ -4794,6 +4947,44 @@ TOOLBAR_SetMaxTextRows (TOOLBAR_INFO *in
     return TRUE;
 }
 
+#ifdef __REACTOS__
+static LRESULT
+TOOLBAR_SetMetrics(TOOLBAR_INFO *infoPtr, TBMETRICS *pMetrics)
+{

+    BOOL changed = FALSE;
+
+    if (!pMetrics)
+        return FALSE;
+
+    /* TODO: check if cbSize is a valid value */
+
+    if (pMetrics->dwMask & TBMF_PAD)
+    {
+        infoPtr->szPadding.cx = pMetrics->cxPad;
+        infoPtr->szPadding.cy = pMetrics->cyPad;
+        changed = TRUE;
+    }
+
+    if (pMetrics->dwMask & TBMF_PAD)
+    {
+        infoPtr->szBarPadding.cx = pMetrics->cxBarPad;
+        infoPtr->szBarPadding.cy = pMetrics->cyBarPad;
+        changed = TRUE;
+    }
+
+    if (pMetrics->dwMask & TBMF_BUTTONSPACING)
+    {
+        infoPtr->szSpacing.cx = pMetrics->cxButtonSpacing;
+        infoPtr->szSpacing.cy = pMetrics->cyButtonSpacing;
+        changed = TRUE;
+    }
+
+    if (changed)
+        TOOLBAR_CalcToolbar(infoPtr);
+
+    return TRUE;
+}
+#endif
 
 /* MSDN gives slightly wrong info on padding.
  * 1. It is not only used on buttons with the BTNS_AUTOSIZE style
@@ -5083,6 +5274,16 @@ TOOLBAR_SetVersion (TOOLBAR_INFO *infoPt
 {
     INT iOldVersion = infoPtr->iVersion;
 
+#ifdef __REACTOS__
+    /* The v6 control doesn't support changing its version */
+    if (iOldVersion == 6)
+        return iOldVersion;
+
+    /* And a control that is not v6 can't be set to be a v6 one */
+    if (iVersion >= 6)
+        return -1;
+#endif
+
     infoPtr->iVersion = iVersion;
 
     if (infoPtr->iVersion >= 5)
@@ -5269,8 +5470,16 @@ TOOLBAR_Create (HWND hwnd, const CREATES
 
     SystemParametersInfoW (SPI_GETICONTITLELOGFONT, 0, &logFont, 0);
     infoPtr->hFont = infoPtr->hDefaultFont = CreateFontIndirectW (&logFont);
-    
+
+#ifdef __REACTOS__
+    {
+        HTHEME theme = OpenThemeData (hwnd, themeClass);
+        if (theme)
+            GetThemeMargins(theme, NULL, TP_BUTTON, TS_NORMAL, TMT_CONTENTMARGINS, NULL, &infoPtr->themeMargins);
+    }
+#else
     OpenThemeData (hwnd, themeClass);
+#endif
 
     TOOLBAR_CheckStyle (infoPtr);
 
@@ -5993,7 +6202,11 @@ TOOLBAR_NCCalcSize (HWND hwnd, WPARAM wP
 
 
 static LRESULT
+#ifdef __REACTOS__
+TOOLBAR_NCCreate (HWND hwnd, WPARAM wParam, const CREATESTRUCTW *lpcs, int iVersion)
+#else
 TOOLBAR_NCCreate (HWND hwnd, WPARAM wParam, const CREATESTRUCTW *lpcs)
+#endif
 {
     TOOLBAR_INFO *infoPtr;
     DWORD styleadd = 0;
@@ -6027,13 +6240,22 @@ TOOLBAR_NCCreate (HWND hwnd, WPARAM wPar
     infoPtr->dwDTFlags = (lpcs->style & TBSTYLE_LIST) ? DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_END_ELLIPSIS: DT_CENTER | DT_END_ELLIPSIS;
     infoPtr->bAnchor = FALSE; /* no anchor highlighting */
     infoPtr->bDragOutSent = FALSE;
+#ifdef __REACTOS__
+    infoPtr->iVersion = iVersion;
+#else
     infoPtr->iVersion = 0;
+#endif
     infoPtr->hwndSelf = hwnd;
     infoPtr->bDoRedraw = TRUE;
     infoPtr->clrBtnHighlight = CLR_DEFAULT;
     infoPtr->clrBtnShadow = CLR_DEFAULT;
     infoPtr->szPadding.cx = DEFPAD_CX;
     infoPtr->szPadding.cy = DEFPAD_CY;
+#ifdef __REACTOS__
+    infoPtr->szSpacing.cx = 0;
+    infoPtr->szSpacing.cy = 0;
+    memset(&infoPtr->themeMargins, 0 , sizeof(infoPtr->themeMargins));
+#endif
     infoPtr->iListGap = DEFLISTGAP;
     infoPtr->iTopMargin = default_top_margin(infoPtr);
     infoPtr->dwStyle = lpcs->style;
@@ -6443,8 +6665,22 @@ TOOLBAR_SysColorChange (void)
     return 0;
 }
 
-
+#ifdef __REACTOS__
 /* update theme after a WM_THEMECHANGED message */
+static LRESULT theme_changed (TOOLBAR_INFO *infoPtr)
+{
+    HTHEME theme = GetWindowTheme (infoPtr->hwndSelf);
+    CloseThemeData (theme);
+    OpenThemeData (infoPtr->hwndSelf, themeClass);
+    theme = GetWindowTheme (infoPtr->hwndSelf);
+    if (theme)
+        GetThemeMargins(theme, NULL, TP_BUTTON, TS_NORMAL, TMT_CONTENTMARGINS, NULL, &infoPtr->themeMargins);
+    else
+        memset(&infoPtr->themeMargins, 0 ,sizeof(infoPtr->themeMargins));
+
+    return 0;
+}
+#else
 static LRESULT theme_changed (HWND hwnd)
 {
     HTHEME theme = GetWindowTheme (hwnd);
@@ -6452,7 +6688,7 @@ static LRESULT theme_changed (HWND hwnd)
     OpenThemeData (hwnd, themeClass);
     return 0;
 }
-
+#endif
 
 static LRESULT WINAPI
 ToolbarWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
@@ -6557,6 +6793,10 @@ ToolbarWindowProc (HWND hwnd, UINT uMsg,
 
 	case TB_GETMAXSIZE:
 	    return TOOLBAR_GetMaxSize (infoPtr, (LPSIZE)lParam);
+#ifdef __REACTOS__
+	case TB_GETMETRICS:
+	    return TOOLBAR_GetMetrics (infoPtr, (TBMETRICS*)lParam);
+#endif
 
 /*	case TB_GETOBJECT:			*/ /* 4.71 */
 
@@ -6698,6 +6938,11 @@ ToolbarWindowProc (HWND hwnd, UINT uMsg,
 	case TB_SETMAXTEXTROWS:
 	    return TOOLBAR_SetMaxTextRows (infoPtr, wParam);
 
+#ifdef __REACTOS__
+	case TB_SETMETRICS:
+	    return TOOLBAR_SetMetrics (infoPtr, (TBMETRICS*)lParam);
+#endif
+
 	case TB_SETPADDING:
 	    return TOOLBAR_SetPadding (infoPtr, lParam);
 
@@ -6805,7 +7050,11 @@ ToolbarWindowProc (HWND hwnd, UINT uMsg,
 	    return TOOLBAR_NCCalcSize (hwnd, wParam, lParam);
 
 	case WM_NCCREATE:
+#ifdef __REACTOS__
+	    return TOOLBAR_NCCreate (hwnd, wParam, (CREATESTRUCTW*)lParam, 0);
+#else
 	    return TOOLBAR_NCCreate (hwnd, wParam, (CREATESTRUCTW*)lParam);
+#endif
 
 	case WM_NCPAINT:
 	    return TOOLBAR_NCPaint (hwnd, wParam, lParam);
@@ -6837,9 +7086,12 @@ ToolbarWindowProc (HWND hwnd, UINT uMsg,
 
 	case WM_SYSCOLORCHANGE:
 	    return TOOLBAR_SysColorChange ();
-            
-        case WM_THEMECHANGED:
+    case WM_THEMECHANGED:
+#ifdef __REACTOS__
+            return theme_changed (infoPtr);
+#else
             return theme_changed (hwnd);
+#endif
 
 /*	case WM_WININICHANGE: */
 
@@ -6887,6 +7139,40 @@ TOOLBAR_Unregister (void)
     UnregisterClassW (TOOLBARCLASSNAMEW, NULL);
 }
 
+#ifdef __REACTOS__
+static LRESULT WINAPI
+ToolbarV6WindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    if (uMsg == WM_NCCREATE)
+        return TOOLBAR_NCCreate (hwnd, wParam, (CREATESTRUCTW*)lParam, 6);
+    else
+        return ToolbarWindowProc(hwnd, uMsg, wParam, lParam);
+}
+
+VOID
+TOOLBARv6_Register (void)
+{
+    WNDCLASSW wndClass;
+
+    ZeroMemory (&wndClass, sizeof(WNDCLASSW));
+    wndClass.style         = CS_GLOBALCLASS | CS_DBLCLKS;
+    wndClass.lpfnWndProc   = ToolbarV6WindowProc;
+    wndClass.cbClsExtra    = 0;
+    wndClass.cbWndExtra    = sizeof(TOOLBAR_INFO *);
+    wndClass.hCursor       = LoadCursorW (0, (LPWSTR)IDC_ARROW);
+    wndClass.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
+    wndClass.lpszClassName = TOOLBARCLASSNAMEW;
+
+    RegisterClassW (&wndClass);
+}
+
+VOID
+TOOLBARv6_Unregister (void)
+{
+    UnregisterClassW (TOOLBARCLASSNAMEW, NULL);
+}
+#endif
+
 static HIMAGELIST TOOLBAR_InsertImageList(PIMLENTRY **pies, INT *cies, HIMAGELIST himl, INT id)
 {
     HIMAGELIST himlold;
diff -pudN e:\wine\dlls\comctl32/tooltips.c e:\reactos\dll\win32\comctl32/tooltips.c
--- e:\wine\dlls\comctl32/tooltips.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/tooltips.c	2017-02-13 10:18:27 +0100
@@ -2009,7 +2009,36 @@ TOOLTIPS_NCHitTest (const TOOLTIPS_INFO 
 static LRESULT
 TOOLTIPS_NotifyFormat (TOOLTIPS_INFO *infoPtr, WPARAM wParam, LPARAM lParam)
 {
+#ifdef __REACTOS__
+    TTTOOL_INFO *toolPtr = infoPtr->tools;
+    LRESULT nResult;
+
+    TRACE("infoPtr=%p wParam=%lx lParam=%p\n", infoPtr, wParam, (PVOID)lParam);
+
+    if (lParam == NF_QUERY) {
+        if (toolPtr->bNotifyUnicode) {
+            return NFR_UNICODE;
+        } else {
+            return NFR_ANSI;
+        }
+    }
+    else if (lParam == NF_REQUERY) {
+        nResult = SendMessageW (toolPtr->hwnd, WM_NOTIFYFORMAT,
+                    (WPARAM)infoPtr->hwndSelf, (LPARAM)NF_QUERY);
+        if (nResult == NFR_ANSI) {
+            toolPtr->bNotifyUnicode = FALSE;
+            TRACE(" -- WM_NOTIFYFORMAT returns: NFR_ANSI\n");
+        } else if (nResult == NFR_UNICODE) {
+            toolPtr->bNotifyUnicode = TRUE;
+            TRACE(" -- WM_NOTIFYFORMAT returns: NFR_UNICODE\n");
+        } else {
+            TRACE (" -- WM_NOTIFYFORMAT returns: error!\n");
+        }
+        return nResult;
+    }
+#else
     FIXME ("hwnd=%p wParam=%lx lParam=%lx\n", infoPtr->hwndSelf, wParam, lParam);
+#endif
 
     return 0;
 }
diff -pudN e:\wine\dlls\comctl32/trackbar.c e:\reactos\dll\win32\comctl32/trackbar.c
--- e:\wine\dlls\comctl32/trackbar.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/trackbar.c	2017-05-07 14:47:57 +0100
@@ -938,7 +938,11 @@ TRACKBAR_Refresh (TRACKBAR_INFO *infoPtr
         if (GetWindowTheme (infoPtr->hwndSelf)) {
             DrawThemeParentBackground (infoPtr->hwndSelf, hdc, 0);
         }
+#ifndef __REACTOS__
         else {
+#else
+        {
+#endif
             HBRUSH brush = (HBRUSH)SendMessageW(infoPtr->hwndNotify, WM_CTLCOLORSTATIC,
                     (WPARAM)hdc, (LPARAM)infoPtr->hwndSelf);
             FillRect (hdc, &rcClient, brush ? brush : GetSysColorBrush(COLOR_BTNFACE));
diff -pudN e:\wine\dlls\comctl32/treeview.c e:\reactos\dll\win32\comctl32/treeview.c
--- e:\wine\dlls\comctl32/treeview.c	2017-09-07 12:58:14 +0100
+++ e:\reactos\dll\win32\comctl32/treeview.c	2017-05-21 20:35:33 +0100
@@ -2911,7 +2911,14 @@ TREEVIEW_Refresh(TREEVIEW_INFO *infoPtr,
 	}
     }
 
+    //
+    // FIXME: This is correct, but is causes and infinite loop of WM_PAINT
+    // messages, resulting in continuous painting of the scroll bar in reactos.
+    // Comment out until the real bug is found. CORE-4912
+    //
+#ifndef __REACTOS__
     TREEVIEW_UpdateScrollBars(infoPtr);
+#endif
 
     if (infoPtr->cdmode & CDRF_NOTIFYPOSTPAINT)
 	infoPtr->cdmode =
@@ -5439,8 +5446,15 @@ static BOOL TREEVIEW_NCPaint (const TREE
         CombineRgn (cliprgn, cliprgn, region, RGN_AND);
     OffsetRect(&r, -r.left, -r.top);
 
+#ifdef __REACTOS__ /* r73789 */
+    dc = GetWindowDC(infoPtr->hwnd);
+    /* Exclude client part */
+    ExcludeClipRect(dc, r.left + cxEdge, r.top + cyEdge,
+        r.right - cxEdge, r.bottom -cyEdge);
+#else
     dc = GetDCEx(infoPtr->hwnd, region, DCX_WINDOW|DCX_INTERSECTRGN);
     OffsetRect(&r, -r.left, -r.top);
+#endif
 
     if (IsThemeBackgroundPartiallyTransparent (theme, 0, 0))
         DrawThemeParentBackground(infoPtr->hwnd, dc, &r);
diff -pudN e:\wine\dlls\comctl32/idc_divider.cur e:\reactos\dll\win32\comctl32/idc_divider.cur
#is kept at older state of ros SVN r75877 to avoid CORE-14144
diff -pudN e:\wine\dlls\comctl32/idc_divideropen.cur e:\reactos\dll\win32\comctl32/idc_divideropen.cur
#is kept at older state of ros SVN r75877 to avoid CORE-14144
